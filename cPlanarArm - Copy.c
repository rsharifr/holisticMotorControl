/***************************************************
 * Automatically generated by Maple.
 * Created On: Fri Nov 14 16:05:15 2014.
***************************************************/
#ifdef WMI_WINNT
#define EXP __declspec(dllexport)
#else
#ifdef X86_64_WINDOWS
#define EXP __declspec(dllexport)
#else
#define EXP
#endif
#endif
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#ifdef FROM_MAPLE
#include <mplshlib.h>
static MKernelVector kv;
EXP ALGEB M_DECL SetKernelVector(MKernelVector kv_in, ALGEB args) { kv=kv_in; return(kv->toMapleNULL()); }
#else
#ifdef WMI_WINNT
#define M_DECL __stdcall
#else
#define M_DECL
#endif
#endif

/***************************************************
* Variable Definition for System:

* State variable(s):
*    x[ 0] = `Main.Model1.MuscleArm1.BiExtensor.Muscle_Thelen_CE2.LM`(t)
*    x[ 1] = `Main.Model1.MuscleArm1.BiExtensor.VN1.u[1]`(t)
*    x[ 2] = `Main.Model1.MuscleArm1.BiExtensor.VN1.u[3]`(t)
*    x[ 3] = `Main.Model1.MuscleArm1.BiExtensor.VN1.y`(t)
*    x[ 4] = `Main.Model1.MuscleArm1.BiFlexor.Muscle_Thelen_CE2.LM`(t)
*    x[ 5] = `Main.Model1.MuscleArm1.BiFlexor.VN1.u[1]`(t)
*    x[ 6] = `Main.Model1.MuscleArm1.BiFlexor.VN1.u[3]`(t)
*    x[ 7] = `Main.Model1.MuscleArm1.BiFlexor.VN1.y`(t)
*    x[ 8] = `Main.Model1.MuscleArm1.ElbowExtensor.Muscle_Thelen_CE2.LM`(t)
*    x[ 9] = `Main.Model1.MuscleArm1.ElbowExtensor.VN1.u[1]`(t)
*    x[10] = `Main.Model1.MuscleArm1.ElbowExtensor.VN1.u[3]`(t)
*    x[11] = `Main.Model1.MuscleArm1.ElbowExtensor.VN1.y`(t)
*    x[12] = `Main.Model1.MuscleArm1.ElbowFlexor.Muscle_Thelen_CE2.LM`(t)
*    x[13] = `Main.Model1.MuscleArm1.ElbowFlexor.VN1.u[1]`(t)
*    x[14] = `Main.Model1.MuscleArm1.ElbowFlexor.VN1.u[3]`(t)
*    x[15] = `Main.Model1.MuscleArm1.ElbowFlexor.VN1.y`(t)
*    x[16] = `Main.Model1.MuscleArm1.ShoulderExtensor.Muscle_Thelen_CE2.LM`(t)
*    x[17] = `Main.Model1.MuscleArm1.ShoulderExtensor.VN1.u[1]`(t)
*    x[18] = `Main.Model1.MuscleArm1.ShoulderExtensor.VN1.u[3]`(t)
*    x[19] = `Main.Model1.MuscleArm1.ShoulderExtensor.VN1.y`(t)
*    x[20] = `Main.Model1.MuscleArm1.ShoulderFlexor.Muscle_Thelen_CE2.LM`(t)
*    x[21] = `Main.Model1.MuscleArm1.ShoulderFlexor.VN1.u[1]`(t)
*    x[22] = `Main.Model1.MuscleArm1.ShoulderFlexor.VN1.u[3]`(t)
*    x[23] = `Main.Model1.MuscleArm1.ShoulderFlexor.VN1.y`(t)
*    x[24] = `Main.Model1.MuscleArm1.zElbow.theta`(t)
*    x[25] = diff(`Main.Model1.MuscleArm1.zElbow.theta`(t),t)
*    x[26] = `Main.Model1.MuscleArm1.zShoulder.theta`(t)
*    x[27] = diff(`Main.Model1.MuscleArm1.zShoulder.theta`(t),t)
*
* Output variable(s):
*    y[ 0] = `Main.Model1.MuscleArm1.zElbow.theta`(t)
*    y[ 1] = diff(`Main.Model1.MuscleArm1.zElbow.theta`(t),t)
*    y[ 2] = `Main.Model1.MuscleArm1.zShoulder.theta`(t)
*    y[ 3] = diff(`Main.Model1.MuscleArm1.zShoulder.theta`(t),t)
*    y[ 4] = `Main.Model1.axyz[1]`(t)
*    y[ 5] = `Main.Model1.axyz[2]`(t)
*    y[ 6] = `Main.Model1.axyz[3]`(t)
*    y[ 7] = `Main.Model1.vxyz[1]`(t)
*    y[ 8] = `Main.Model1.vxyz[2]`(t)
*    y[ 9] = `Main.Model1.vxyz[3]`(t)
*    y[10] = `Main.Model1.xyz[1]`(t)
*    y[11] = `Main.Model1.xyz[2]`(t)
*    y[12] = `Main.Model1.xyz[3]`(t)
*    y[13] = `Main.Model1.FBiExt`(t)
*    y[14] = `Main.Model1.FBiFlex`(t)
*    y[15] = `Main.Model1.FElExt`(t)
*    y[16] = `Main.Model1.FElFlex`(t)
*    y[17] = `Main.Model1.FShExt`(t)
*    y[18] = `Main.Model1.FShFlex`(t)
*
* Input variable(s):
*    u[ 0] = `Main.Model1.Fx`(t)
*    u[ 1] = `Main.Model1.Fz`(t)
*    u[ 2] = `Main.Model1.aBiExt`(t)
*    u[ 3] = `Main.Model1.aBiFlex`(t)
*    u[ 4] = `Main.Model1.aElExt`(t)
*    u[ 5] = `Main.Model1.aElFlex`(t)
*    u[ 6] = `Main.Model1.aShExt`(t)
*    u[ 7] = `Main.Model1.aShFlex`(t)
*
* Parameter(s):
*    p[ 0] = `Main.Model1.KdEl` (default = 1.)
*    p[ 1] = `Main.Model1.KdSh` (default = 1.)
*
************************************************/

/* Set up fixed initial condition mask */
long icmask[28] = {
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,1,1,1,1};

/* Configurable parameters */
#define CONITER 3
#define CONTOL 1.000000e-05
#define INITCONITER 100
#define INITCONTOL 1.000000e-10
#define INITITER 50
#define INITTOL 1.000000e-08
#define INITWEIGHT 2.000000e+01
#define INCONTOL 1e200

/* Fixed parameters */
#define NDIFF 28
#define NDFA 28
#define NEQ 83
#define NPAR 2
#define NINP 8
#define NDISC 0
#define NIX1 55
#define NOUT 19
#define NCON 24
#define NEVT 0
#ifdef EVTHYST
#define NZC 2*NEVT
#else
#define NZC NEVT
#endif

typedef struct {
	double h;		/* Integration step size */
	double *w;		/* Float workspace */
	long *iw;		/* Integer workspace */
	long err;		/* Error flag */
	char *buf;		/* Error message */
} SolverStruct;

static void SolverError(SolverStruct *S, int term, char *errmsg)
{
#ifdef FROM_MAPLE
	long i;
#endif
	if(term)
		sprintf(S->buf,"Simulation terminated at t=%20.16e: %s\n",S->w[0],errmsg);
	else
		sprintf(S->buf,"Error at t=%20.16e: %s\n",S->w[0],errmsg);
#ifdef FROM_MAPLE
	for(i=0;S->buf[i]!='\0';i++);
	S->buf[i-1]='\0';
	if(S->err==-1) kv->error(S->buf);
#endif
	S->err=1;
}

static double dsn_zero=0.0;
static unsigned char dsn_undefC[8] = { 0, 0, 0, 0, 0, 0, 0xF8, 0x7F };
static double *dsn_undef = (double *)&dsn_undefC;
static unsigned char dsn_posinfC[8] = { 0, 0, 0, 0, 0, 0, 0xF0, 0x7F };
static double *dsn_posinf = (double *)&dsn_posinfC;
static unsigned char dsn_neginfC[8] = { 0, 0, 0, 0, 0, 0, 0xF0, 0xFF };
static double *dsn_neginf = (double *)&dsn_neginfC;
#define trunc(v) ( (v>0.0) ? floor(v) : ceil(v) )
#define IS_UNDEF(a) (a-a!=0. || (a!=0. && a-2.*a==0.))


#ifdef MSVC
#pragma optimize( "gty", on)
#endif
#ifndef INCONTOL
#define INCONTOL 1e-14
#endif

static void LSQDecompSolve(long n, double *A, long Ainc, long *ip, double *b)
{
	long i,j,k,r,c,lsq,cp;
	double s,t;

	for(i=0;i<n;i++) {
		t = fabs(A[i*Ainc]);
		for(j=1;j<n;j++) {
			s = fabs(A[i*Ainc+j]);
			if(s>t) t = s;
		}
		if( t==0.0 )
			A[i*Ainc+n] = 1.0;
		else {
			t = 1.0/t;
			for(j=0;j<n;j++) A[i*Ainc+j] *= t;
			b[i] *= t;
			A[i*Ainc+n] = t;
		}
	}

	for(j=0;j<n;j++) {
		t = fabs(A[j]);
		for(i=1;i<n;i++) {
			s = fabs(A[i*Ainc+j]);
			if(s>t) t = s;
		}
		if( t==0.0 )
			A[n*Ainc+j] = 1.0;
		else {
			t = 1.0/t;
			for(i=0;i<n;i++) A[i*Ainc+j] *= t;
			A[n*Ainc+j] = t;
		}
	}

	ip[n-1] = 0;
	lsq = 0;
	cp = 0;
	for(k=0;k<n;k++) {
		r = 0; c = 0; t = 0.0;
		if( cp<n ) {
			for(cp=cp+1;cp<n;cp++) {
				for(i=k;i<n;i++) {
					s = fabs(A[i*Ainc+cp]);
					if(s>t) { r = i; c = cp; t = s; }
				}
				if( t>0.5 ) break;
			}
		}
		if( cp>=n ) {
			for(i=k;i<n;i++)
				for(j=k;j<n;j++) {
					s = fabs(A[i*Ainc+j]);
					if(s>t) { r = i; c = j; t = s; }
				}
		}
		if( t<1e-10 ) {
			if( k==0 ) { ip[n-1]=0; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
			if( lsq ) { ip[n-1]=0; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
			lsq = 1;
			t = 1e-100;
			for(i=0;i<k;i++) {
				s = fabs(b[i]);
				if(s>t) t = s;
			}
			for(i=k;i<n;i++) {
				if( fabs(b[i])/t>INCONTOL*n ) { ip[n-1]=0; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
				b[i] = 0.0;
			}

			for(r=k;r<n;r++) {
				for(i=k;i<n;i++) A[i*Ainc+n+r] = 0.0; A[r*Ainc+n+r] = 1.0;
   			A[(k-1)*Ainc+n+r] = -A[(k-1)*Ainc+r]/A[(k-1)*Ainc+k-1];
   			for(i=k-1;i>=0;i--) {
					A[i*Ainc+n+r] = A[i*Ainc+r];
      			for(j=i+1;j<k;j++)
         			A[i*Ainc+n+r] += A[i*Ainc+j]*A[j*Ainc+n+r];
      			A[i*Ainc+n+r] = -A[i*Ainc+n+r]/A[i*(Ainc+1)];
   			}
			}
			for(r=0;r<k;r++) {
				s = -1.0/A[r*(Ainc+1)];
				for(i=k;i<n;i++)
					if( A[r*Ainc+n+i]!=0.0 ) {
						t = s*A[r*Ainc+n+i];
						A[i*Ainc+r] += t;
						for(j=r+1;j<n;j++)
							A[j*Ainc+n+i] += t*A[r*Ainc+j];
						b[i] += t*b[r];
					}
			}
			for(i=k;i<n;i++)
				for(j=k;j<n;j++)
					A[i*Ainc+j] = A[j*Ainc+n+i];
			r = 0; c = 0; t = 0.0;
			for(i=k;i<n;i++)
				for(j=k;j<n;j++) {
					s = fabs(A[i*Ainc+j]);
					if(s>t) { r = i; c = j; t = s; }
				}
			if( t<1e-10 ) { ip[n-1]=0; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
		}
		if( !lsq ) ip[n-1]++;
		if( k==n-1 ) break;
		ip[k] = r;
		ip[n+k] = c;
		if( r>k ) {
			for(j=0;j<n;j++) {
				t = A[r*Ainc+j]; A[r*Ainc+j] = A[k*Ainc+j]; A[k*Ainc+j] = t;
			}
			t = b[r]; b[r] = b[k]; b[k] = t;
		}
		if( c>k )
			for(i=0;i<n;i++) {
				t = A[i*Ainc+c]; A[i*Ainc+c] = A[i*Ainc+k]; A[i*Ainc+k] = t;
			}
		s = -1.0/A[k*(Ainc+1)];
		for(i=k+1;i<n;i++)
			if( A[i*Ainc+k]!=0.0 ) {
				t = s*A[i*Ainc+k];
				A[i*Ainc+k] = t;
				for(j=k+1;j<n;j++)
					A[i*Ainc+j] += t*A[k*Ainc+j];
				b[i] += t*b[k];
			}
	}
	for(j=n-1;j>0;j--) {
		b[j] = b[j]/A[j*(Ainc+1)];
		t = -b[j];
		for(i=0;i<j;i++)
			b[i] += t*A[i*Ainc+j];
	}
	b[0] = b[0]/A[0];
	for(j=n-2;j>=0;j--) {
		i = ip[n+j];
		if(i!=j) {
			t = b[i]; b[i] = b[j]; b[j] = t;
		}
	}
	for(j=0;j<n;j++) b[j] *= A[n*Ainc+j];
}
#ifdef MSVC
#pragma optimize( "", on)
#endif

#ifdef MSVC
#pragma optimize( "gty", on)
#endif
static void DecompCInc(long n, double *A, long Ainc, long *ip)
{
	long i,j,k,m;
	double t;

	ip[n-1]=1;
	for(k=0;k<n-1;k++) {
		m=k;
		for(i=k+1;i<n;i++)
			if( fabs(A[i*Ainc+k])>fabs(A[m*Ainc+k]) ) m=i;
		ip[k]=m;
		if( m!=k ) ip[n-1]=-ip[n-1];
		t=A[m*Ainc+k]; A[m*Ainc+k]=A[(Ainc+1)*k]; A[(Ainc+1)*k]=t;
		if( t==0.0 ) { ip[n-1]=0; return; }
		t=-1.0/t;
		for(i=k+1;i<n;i++) A[i*Ainc+k]=A[i*Ainc+k]*t;
		for(j=k+1;j<n;j++) {
			t=A[m*Ainc+j]; A[m*Ainc+j]=A[k*Ainc+j]; A[k*Ainc+j]=t;
			if( t!=0.0 )
				for(i=k+1;i<n;i++) A[i*Ainc+j]+=A[i*Ainc+k]*t;
		}
	}
	if(A[(n-1)*(Ainc+1)]==0.0) ip[n-1]=0;
}
static void DecompC(long n, double *A, long *ip) { DecompCInc(n,A,n,ip); }

#ifdef MSVC
#pragma optimize( "", on)
#endif

#ifdef MSVC
#pragma optimize( "gty", on)
#endif
static void MultiSolveCInc(long n, double *A, long Ainc, long *ip, long nb, double *b, long binc)
{
	long i,j,k,m;
	double t;

	if( n>1 ) {
		for(j=0;j<n-1;j++) {
			m=ip[j];
			for(k=0;k<nb;k++) {
				t=b[m*binc+k]; b[m*binc+k]=b[j*binc+k]; b[j*binc+k]=t;
				for(i=j+1;i<n;i++) b[i*binc+k]+=A[i*Ainc+j]*t;
			}
		}
		for(j=n-1;j>0;j--) {
			for(k=0;k<nb;k++) {
				b[j*binc+k]=b[j*binc+k]/A[(Ainc+1)*j];
				t=-b[j*binc+k];
				for(i=0;i<=j-1;i++) b[i*binc+k]+=A[i*Ainc+j]*t;
			}
		}
	}
	for(k=0;k<nb;k++)
		b[k]=b[k]/A[0];
}
static void MultiSolveC(long n, double *A, long *ip, long nb, double *b) { MultiSolveCInc(n,A,n,ip,nb,b,nb); }

#ifdef MSVC
#pragma optimize( "", on)
#endif

static void fp(long N, double T, double *Y, double *YP)
{
	double M[12], V[2], Z[50], td1, td2;
	long P[3], ti1, ti2, ti3;

	YP[24] = Y[25];
	YP[26] = Y[27];
	Z[0] = Y[78];
	Y[33] = 0.25+0.75*Z[0];
	Z[1] = -1.+7.750315560841073231*Y[4];
	Y[34] = exp(-2.222222222222222222*Z[1]*Z[1]);
	Z[1] = sin(Y[26]);
	Z[2] = cos(Y[24]);
	Z[3] = cos(Y[26]);
	Z[4] = sin(Y[24]);
	Z[5] = Y[25]+Y[27];
	Z[6] = Z[5]*Z[2];
	Z[7] = Z[3]*Z[4]*Z[5]+Z[1]*Z[6];
	Z[5] = Z[1]*Z[4]*Z[5]-Z[3]*Z[6];
	Z[6] = -0.004258009264589300018;
	Z[8] = -0.31*Y[27];
	Z[9] = Z[8]*Z[1];
	YP[5] = Z[5]*Z[6]+Z[9]-0.04715016227153790061*Z[7];
	Z[8] = Z[8]*Z[3];
	YP[6] = Z[6]*Z[7]+Z[8]+0.04715016227153790061*Z[5];
	Z[6] = Y[5]*Y[5]+Y[6]*Y[6];
	Z[10] = fabs(Z[6]);
	if( Z[10]<=0. ) {
		YP[0] = (*dsn_posinf);
		return;
	}
	if( Z[6]>0. )
		ti1 = 1;
	else if( Z[6]<0. )
		ti1 = -1;
	else
		ti1 = 0;
	YP[7] = (1.0/(sqrt(Z[10])))*(Y[5]*YP[5]+Y[6]*YP[6])*((double)ti1);
	Z[6] = Y[7]-0.1876654718923540032;
	if( Z[6]>0. )
		ti1 = 1;
	else if( Y[7]<0.1876654718923540032 )
		ti1 = -1;
	else
		ti1 = 0;
	YP[4] = YP[7]*((double)ti1);
	Y[36] = YP[4];
	if( Y[36]<=0. )
		Y[35] = (8.*Y[33]+0.9687894451051341538*Y[36])/(8.*Y[33]-3.875157780420536615*Y[36]);
	else
		Y[35] = (6.4*Y[33]+17.43821001189241477*Y[36])/(6.4*Y[33]+9.687894451051341538*Y[36]);
	Z[10] = Y[77];
	Y[28] = 0.25+0.75*Z[10];
	Z[11] = -1.+6.977473088430686526*Y[0];
	Y[29] = exp(-2.222222222222222222*Z[11]*Z[11]);
	Y[37] = (-971.6839440783530021*Z[0]*Y[34]*Y[35]*Z[6])/Y[4];
	YP[1] = Z[9]-0.01869724304842369895*Z[5]+0.01737446805143240149*Z[7];
	YP[2] = Z[8]-0.01869724304842369895*Z[7]-0.01737446805143240149*Z[5];
	Z[0] = Y[1]*Y[1]+Y[2]*Y[2];
	Z[5] = fabs(Z[0]);
	if( Z[5]<=0. ) {
		YP[0] = (*dsn_posinf);
		return;
	}
	if( Z[0]>0. )
		ti1 = 1;
	else if( Z[0]<0. )
		ti1 = -1;
	else
		ti1 = 0;
	YP[3] = (1.0/(sqrt(Z[5])))*(Y[1]*YP[1]+Y[2]*YP[2])*((double)ti1);
	Z[0] = Y[3]-0.1191861621963549957;
	Z[5] = Z[0]*Z[0]+0.000887894734126077383;
	YP[0] = (1.0/(sqrt(Z[5])))*Z[0]*YP[3];
	Y[31] = YP[0];
	if( Y[31]<=0. )
		Y[30] = (8.*Y[28]+0.8721841360538358158*Y[31])/(8.*Y[28]-3.488736544215343263*Y[31]);
	else
		Y[30] = (6.4*Y[28]+15.6993144489690447*Y[31])/(6.4*Y[28]+8.721841360538358158*Y[31]);
	Y[32] = (-798.520000000001*Z[10]*Y[29]*Y[30]*Z[0])/Y[0];
	Z[0] = Y[79];
	Y[38] = 0.25+0.75*Z[0];
	Z[5] = -1.+9.198113187076896769*Y[8];
	Y[39] = exp(-2.222222222222222222*Z[5]*Z[5]);
	YP[9] = Y[25]*(0.01939984557043140074*Z[4]-0.0003627956121079530131*Z[2]);
	YP[10] = Y[25]*(0.01939984557043140074*Z[2]+0.0003627956121079530131*Z[4]);
	Z[5] = Y[9]*Y[9]+Y[10]*Y[10];
	Z[6] = fabs(Z[5]);
	if( Z[6]<=0. ) {
		YP[0] = (*dsn_posinf);
		return;
	}
	if( Z[5]>0. )
		ti1 = 1;
	else if( Z[5]<0. )
		ti1 = -1;
	else
		ti1 = 0;
	YP[11] = (1.0/(sqrt(Z[6])))*(Y[9]*YP[9]+Y[10]*YP[10])*((double)ti1);
	Z[5] = Y[11]-0.007207271244649430134;
	Z[6] = Z[5]*Z[5]+0.000215371568910646808;
	YP[8] = (1.0/(sqrt(Z[6])))*Z[5]*YP[11];
	Y[41] = YP[8];
	if( Y[41]<=0. )
		Y[40] = (8.*Y[38]+1.149764148384612096*Y[41])/(8.*Y[38]-4.599056593538448384*Y[41]);
	else
		Y[40] = (6.4*Y[38]+20.6957546709230177*Y[41])/(6.4*Y[38]+11.49764148384612096*Y[41]);
	Y[42] = (-1577.017267470980048*Z[0]*Y[39]*Y[40]*Z[5])/Y[8];
	Z[0] = Y[80];
	Y[43] = 0.25+0.75*Z[0];
	Z[5] = -1.+8.537934980611337468*Y[12];
	Y[44] = exp(-2.222222222222222222*Z[5]*Z[5]);
	Z[5] = -0.04973713162428480153;
	YP[13] = Y[25]*(Z[4]*Z[5]+0.001781419218562789957*Z[2]);
	YP[14] = Y[25]*(Z[5]*Z[2]-0.001781419218562789957*Z[4]);
	Z[2] = Y[13]*Y[13]+Y[14]*Y[14];
	Z[4] = fabs(Z[2]);
	if( Z[4]<=0. ) {
		YP[0] = (*dsn_posinf);
		return;
	}
	if( Z[2]>0. )
		ti1 = 1;
	else if( Z[2]<0. )
		ti1 = -1;
	else
		ti1 = 0;
	YP[15] = (1.0/(sqrt(Z[4])))*(Y[13]*YP[13]+Y[14]*YP[14])*((double)ti1);
	Z[2] = Y[15]-0.01811680735798800181;
	Z[4] = Z[2]*Z[2]+8.35663532754437087e-06;
	YP[12] = (1.0/(sqrt(Z[4])))*Z[2]*YP[15];
	Y[46] = YP[12];
	if( Y[46]<=0. )
		Y[45] = (8.*Y[43]+1.067241872576417184*Y[46])/(8.*Y[43]-4.268967490305668734*Y[46]);
	else
		Y[45] = (6.4*Y[43]+19.2103537063755093*Y[46])/(6.4*Y[43]+10.67241872576417184*Y[46]);
	Y[47] = (-1452.279722084529891*Z[0]*Y[44]*Y[45]*Z[2])/Y[12];
	Z[0] = Y[81];
	Y[48] = 0.25+0.75*Z[0];
	Z[2] = -1.+4.558888341355517176*Y[16];
	Y[49] = exp(-2.222222222222222222*Z[2]*Z[2]);
	Z[2] = -0.04465499663169130187;
	YP[17] = Y[27]*(Z[1]*Z[2]+2.219775824563799962e-09*Z[3]);
	YP[18] = Y[27]*(Z[2]*Z[3]-2.219775824563799962e-09*Z[1]);
	Z[2] = Y[17]*Y[17]+Y[18]*Y[18];
	Z[4] = fabs(Z[2]);
	if( Z[2]>0. )
		ti1 = 1;
	else if( Z[2]<0. )
		ti1 = -1;
	else
		ti1 = 0;
	YP[19] = (1.0/(sqrt(Z[4])))*(Y[17]*YP[17]+Y[18]*YP[18])*((double)ti1);
	Z[2] = Y[19]*Y[19]+0.00533651695611219545;
	if( Z[2]<=0. ) {
		YP[0] = (*dsn_posinf);
		return;
	}
	YP[16] = (1.0/(sqrt(Z[2])))*Y[19]*YP[19];
	Y[51] = YP[16];
	if( Y[51]<=0. )
		Y[50] = (8.*Y[48]+0.569861042669439647*Y[51])/(8.*Y[48]-2.279444170677758588*Y[51]);
	else
		Y[50] = (6.4*Y[48]+10.25749876804991365*Y[51])/(6.4*Y[48]+5.69861042669439647*Y[51]);
	Y[52] = (-1672.43249129511998*Z[0]*Y[49]*Y[50]*Y[19])/Y[16];
	Z[0] = Y[82];
	Y[53] = 0.25+0.75*Z[0];
	Z[2] = -1.+8.328974649881849784*Y[20];
	Y[54] = exp(-2.222222222222222222*Z[2]*Z[2]);
	Z[2] = -0.07526215029278779926;
	YP[21] = Y[27]*(Z[1]*Z[2]-0.0274739834837783004*Z[3]);
	YP[22] = Y[27]*(Z[2]*Z[3]+0.0274739834837783004*Z[1]);
	Z[1] = Y[21]*Y[21]+Y[22]*Y[22];
	Z[2] = fabs(Z[1]);
	if( Z[1]>0. )
		ti1 = 1;
	else if( Z[1]<0. )
		ti1 = -1;
	else
		ti1 = 0;
	YP[23] = (1.0/(sqrt(Z[2])))*(Y[21]*YP[21]+Y[22]*YP[22])*((double)ti1);
	Z[1] = Y[23]-0.02916969277103229945;
	Z[2] = Z[1]*Z[1]+0.00195901209279177268;
	YP[20] = (1.0/(sqrt(Z[2])))*Z[1]*YP[23];
	Y[56] = YP[20];
	if( Y[56]<=0. )
		Y[55] = (8.*Y[53]+1.041121831235231223*Y[56])/(8.*Y[53]-4.164487324940924892*Y[56]);
	else
		Y[55] = (6.4*Y[53]+18.74019296223416201*Y[56])/(6.4*Y[53]+10.41121831235231223*Y[56]);
	Y[57] = (-2524.662523332499958*Z[0]*Y[54]*Y[55]*Z[1])/Y[20];
	for(ti2=0;ti2<=1;ti2++)
		for(ti3=0;ti3<=1;ti3++)
			M[ti2*4+ti3] = 0.;
	for(ti2=0;ti2<=1;ti2++)
		V[ti2] = 0.;
	Z[0] = cos(Y[26]);
	Z[1] = sin(Y[24]);
	Z[2] = sin(Y[26]);
	Z[3] = cos(Y[24]);
	Z[4] = Z[0]*Z[1]+Z[2]*Z[3];
	Z[5] = Z[0]*Z[3]-Z[1]*Z[2];
	Z[6] = 0.054872;
	Z[6] = Z[6]*(Z[4]*Z[4]+Z[5]*Z[5]);
	M[0] = Z[6]+0.0188;
	Z[7] = 0.2888*Z[4];
	Z[8] = 0.4712*Z[2];
	Z[9] = Z[8]+Z[7];
	Z[10] = 0.2888*Z[5];
	Z[11] = 0.4712*Z[0];
	Z[12] = -(Z[11]+Z[10]);
	Z[13] = 0.19;
	Z[14] = Z[13]*(Z[4]*Z[9]-Z[5]*Z[12]);
	M[1] = Z[14]+0.0188;
	Z[15] = 0.01939984557043140074*Z[3];
	Z[16] = -0.0003627956121079530131*Z[1];
	Z[17] = Z[16]-Z[15]+0.1009578529976279903;
	Z[18] = 0.01939984557043140074*Z[1];
	Z[19] = -0.0003627956121079530131*Z[3];
	Z[20] = Z[18]+Z[19]-0.0001612100150651070088;
	Z[21] = Z[17]*Z[17]+Z[20]*Z[20];
	Z[22] = 0.001781419218562789957*Z[1];
	Z[23] = 0.04973713162428480153*Z[3];
	Z[24] = Z[23]+Z[22]+0.1001922804;
	Z[3] = 0.001781419218562789957*Z[3];
	Z[1] = 0.04973713162428480153*Z[1];
	Z[25] = Z[3]-Z[1]-0.001196151814771630075;
	Z[26] = Z[24]*Z[24]+Z[25]*Z[25];
	Z[27] = 0.01869724304842369895*Z[4];
	Z[28] = 0.31*Z[0];
	Z[29] = 0.01737446805143240149*Z[5];
	Z[30] = Z[28]+Z[27]-Z[29]-6.287826248000000487e-08;
	Z[31] = 0.01869724304842369895*Z[5];
	Z[32] = 0.31*Z[2];
	Z[33] = 0.01737446805143240149*Z[4];
	Z[34] = Z[33]+Z[31]-Z[32]-0.03145769966334020184;
	Z[35] = Z[30]*Z[30]+Z[34]*Z[34];
	Z[36] = 0.004258009264589300018*Z[4];
	Z[37] = 0.04715016227153790061*Z[5];
	Z[28] = Z[37]+Z[28]+Z[36]+0.009977209043000000111;
	Z[38] = 0.004258009264589300018*Z[5];
	Z[39] = 0.04715016227153790061*Z[4];
	Z[32] = Z[38]-Z[39]-Z[32]+0.03143025891654109997;
	Z[40] = Z[28]*Z[28]+Z[32]*Z[32];
	if( Z[35]<=0. ) {
		YP[0] = (*dsn_posinf);
		return;
	}
	if( Z[35]>0. )
		Z[41] = Y[32]*(1.0/(sqrt(Z[35])));
	else
		Z[41] = 0.;
	if( Z[40]<=0. ) {
		YP[0] = (*dsn_posinf);
		return;
	}
	if( Z[40]>0. )
		Z[42] = Y[37]*(1.0/(sqrt(Z[40])));
	else
		Z[42] = 0.;
	if( Z[21]<=0. ) {
		YP[0] = (*dsn_posinf);
		return;
	}
	if( Z[21]>0. )
		Z[43] = Y[42]*(1.0/(sqrt(Z[21])));
	else
		Z[43] = 0.;
	if( Z[26]<=0. ) {
		YP[0] = (*dsn_posinf);
		return;
	}
	if( Z[26]>0. )
		Z[44] = Y[47]*(1.0/(sqrt(Z[26])));
	else
		Z[44] = 0.;
	Z[45] = Y[76];
	Z[46] = Y[75];
	Z[47] = Y[25]+Y[27];
	Z[48] = Y[27]*Y[27];
	Z[47] = 0.2888*Z[47]*Z[47];
	Z[49] = Z[47]*Z[5];
	Z[11] = Z[11]*Z[48];
	Z[47] = Z[47]*Z[4];
	Z[8] = Z[8]*Z[48];
	Z[15] = (Z[20]*Z[16]-Z[20]*Z[15]-Z[17]*Z[18]-Z[17]*Z[19])*Z[43];
	Z[16] = (Z[34]*Z[27]-Z[34]*Z[29]-Z[30]*Z[31]-Z[30]*Z[33])*Z[41];
	Z[18] = (Z[28]*Z[39]+Z[32]*Z[36]+Z[32]*Z[37]-Z[28]*Z[38])*Z[42];
	Z[1] = (Z[24]*Z[1]+Z[25]*Z[22]+Z[25]*Z[23]-Z[24]*Z[3])*Z[44];
	Z[3] = -0.15;
	Z[13] = Z[13]*(Z[4]*Z[11]+Z[4]*Z[45]+Z[4]*Z[49]-Z[5]*Z[8]-Z[5]*Z[46]-Z[47]*Z[5]);
	Z[3] = Z[3]*(Z[4]*Z[45]-Z[5]*Z[46]);
	V[0] = Z[3]-Y[25]*Y[83]-Z[1]-Z[13]-Z[15]-Z[16]-Z[18];
	Z[19] = 0.089528;
	M[4] = Z[19]*(Z[0]*Z[5]+Z[2]*Z[4])+Z[6]+0.0188;
	Z[4] = 0.78965*Z[2];
	Z[5] = 0.78965*Z[0];
	Z[6] = 0.165;
	Z[19] = 0.145;
	M[5] = Z[6]*(Z[0]*Z[5]+Z[0]*Z[10]+Z[2]*Z[4]+Z[2]*Z[7])+Z[14]-Z[19]*(Z[0]*Z[12]-Z[2]*Z[9])+0.0329;
	Z[7] = 0.07526215029278779926*Z[0];
	Z[9] = -0.0274739834837783004*Z[2];
	Z[10] = Z[9]+Z[7]+0.07179454623553609659;
	Z[12] = 0.07526215029278779926*Z[2];
	Z[14] = -0.0274739834837783004*Z[0];
	Z[22] = Z[14]-Z[12]+0.03211993553327720254;
	Z[23] = Z[10]*Z[10]+Z[22]*Z[22];
	Z[27] = 2.219775824563799962e-09*Z[2];
	Z[29] = 0.04465499663169130187*Z[0];
	Z[31] = Z[29]+Z[27]-2.219790209527749963e-09;
	Z[33] = 2.219775824563799962e-09*Z[0];
	Z[36] = 0.04465499663169130187*Z[2];
	Z[37] = Z[33]-Z[36]-0.04465497329256169882;
	Z[38] = Z[31]*Z[31]+Z[37]*Z[37];
	Z[28] = Z[28]*Z[42]+Z[30]*Z[41]+Z[45];
	Z[30] = Z[46]-Z[32]*Z[42]-Z[34]*Z[41];
	if( Z[23]<=0. ) {
		YP[0] = (*dsn_posinf);
		return;
	}
	if( Z[38]<=0. ) {
		YP[0] = (*dsn_posinf);
		return;
	}
	if( Z[23]>0. )
		td1 = Y[57]*(1.0/(sqrt(Z[23])));
	else
		td1 = 0.;
	if( Z[38]>0. )
		td2 = Y[52]*(1.0/(sqrt(Z[38])));
	else
		td2 = 0.;
	V[1] = Z[19]*(Z[0]*Z[8]+Z[0]*Z[30]+Z[0]*Z[47]-Z[2]*Z[11]-Z[2]*Z[28]-Z[2]*Z[49])+Z[43]*(-0.1009578529976279903*Z[20]-0.0001612100150651070088*Z[17])+Z[44]*(-0.001196151814771630075*Z[24]-0.1001922804*Z[25])+Z[3]-Z[6]*(Z[2]*Z[5]*Z[48]+Z[2]*Z[28]+Z[2]*Z[49]-Z[0]*Z[4]*Z[48]-Z[0]*Z[30]-Z[0]*Z[47])-Z[13]-Y[84]*Y[27]-(Z[22]*Z[7]+Z[22]*Z[9]+Z[10]*Z[12]-Z[10]*Z[14])*td1-(Z[37]*Z[27]+Z[37]*Z[29]+Z[31]*Z[36]-Z[31]*Z[33])*td2-Z[1]-Z[15]-Z[16]-Z[18];
	LSQDecompSolve(2,M,4,P,V);
	YP[25] = V[0];
	YP[27] = V[1];
	Y[58] = YP[25];
	Y[59] = YP[27];
}

static void otp(double T, double *Y, double *YP)
{
	double Z[13];

	Y[60] = -Y[32];
	Y[61] = -Y[37];
	Y[62] = -Y[42];
	Y[63] = -Y[47];
	Y[64] = -Y[52];
	Y[65] = -Y[57];
	Z[0] = Y[59]+Y[58];
	Z[1] = cos(Y[26]);
	Z[2] = cos(Y[24]);
	Z[3] = sin(Y[26]);
	Z[4] = sin(Y[24]);
	Z[5] = Z[3]*Z[4];
	Z[6] = Z[1]*Z[2]-Z[5];
	Z[7] = Y[25]+Y[27];
	Z[4] = Z[1]*Z[4];
	Z[8] = Z[2]*Z[3]+Z[4];
	Z[9] = Y[27]*Y[27];
	Z[10] = Z[7]*Z[7];
	Z[11] = 0.31;
	Z[12] = 0.34;
	Y[66] = -(Z[11]*(Z[3]*Z[9]-Z[1]*Y[59])+Z[12]*(Z[8]*Z[10]-Z[0]*Z[6]));
	Y[67] = 0.;
	Y[68] = -(Z[11]*(Z[3]*Y[59]+Z[1]*Z[9])+Z[12]*(Z[0]*Z[8]+Z[6]*Z[10]));
	Z[0] = Z[12]*Z[7];
	Z[7] = Z[11]*Y[27];
	Y[69] = Z[0]*Z[6]+Z[1]*Z[7];
	Y[70] = 0.;
	Y[71] = -(Z[0]*Z[8]+Z[3]*Z[7]);
	Z[0] = Z[2]*Z[12]+Z[11];
	Y[72] = Z[0]*Z[3]+Z[4]*Z[12];
	Y[73] = 0.;
	Y[74] = Z[0]*Z[1]-Z[5]*Z[12];
}

static void Rp(double T, double *Y, double *R)
{
	double Z[11];

	Z[0] = cos(Y[26]);
	Z[1] = cos(Y[24]);
	Z[2] = sin(Y[26]);
	Z[3] = sin(Y[24]);
	Z[4] = Z[0]*Z[1]-Z[2]*Z[3];
	Z[5] = Z[0]*Z[3]+Z[1]*Z[2];
	Z[6] = 0.04715016227153790061;
	Z[7] = 0.009977209043000000111;
	Z[8] = 0.004258009264589300018;
	Z[9] = 0.31*Z[0];
	R[0] = Z[4]*Z[6]+Z[5]*Z[8]+Z[7]+Z[9]-Y[5];
	Z[7] = 0.03143025891654109997;
	Z[10] = 0.31*Z[2];
	R[1] = Z[4]*Z[8]+Z[7]-Z[5]*Z[6]-Y[6]-Z[10];
	Z[6] = fabs(Y[5]*Y[5]+Y[6]*Y[6]);
	R[2] = Y[7]-sqrt(Z[6]);
	R[3] = Y[4]-fabs(Y[7]-0.1876654718923540032);
	Z[6] = 0.01737446805143240149;
	Z[7] = -6.287826248000000487e-08;
	Z[8] = 0.01869724304842369895;
	R[4] = Z[5]*Z[8]+Z[7]+Z[9]-Z[4]*Z[6]-Y[1];
	Z[7] = -0.03145769966334020184;
	R[5] = Z[4]*Z[8]+Z[5]*Z[6]+Z[7]-Y[2]-Z[10];
	Z[4] = fabs(Y[1]*Y[1]+Y[2]*Y[2]);
	R[6] = Y[3]-sqrt(Z[4]);
	Z[4] = Y[3]-0.1191861621963549957;
	Z[4] = Z[4]*Z[4]+0.000887894734126077383;
	R[7] = Y[0]-sqrt(Z[4]);
	Z[4] = 0.01939984557043140074;
	Z[5] = -0.0003627956121079530131;
	Z[6] = 0.1009578529976279903;
	R[8] = Z[3]*Z[5]+Z[6]-Z[1]*Z[4]-Y[9];
	Z[6] = -0.0001612100150651070088;
	R[9] = Z[1]*Z[5]+Z[3]*Z[4]+Z[6]-Y[10];
	Z[4] = fabs(Y[9]*Y[9]+Y[10]*Y[10]);
	R[10] = Y[11]-sqrt(Z[4]);
	Z[4] = Y[11]-0.007207271244649430134;
	Z[4] = Z[4]*Z[4]+0.000215371568910646808;
	R[11] = Y[8]-sqrt(Z[4]);
	Z[4] = 0.04973713162428480153;
	Z[5] = 0.001781419218562789957;
	Z[6] = 0.1001922804;
	R[12] = Z[1]*Z[4]+Z[3]*Z[5]+Z[6]-Y[13];
	Z[6] = -0.001196151814771630075;
	R[13] = Z[1]*Z[5]+Z[6]-Z[3]*Z[4]-Y[14];
	Z[1] = fabs(Y[13]*Y[13]+Y[14]*Y[14]);
	R[14] = Y[15]-sqrt(Z[1]);
	Z[1] = Y[15]-0.01811680735798800181;
	Z[1] = Z[1]*Z[1]+8.35663532754437087e-06;
	R[15] = Y[12]-sqrt(Z[1]);
	Z[1] = -2.219790209527749963e-09;
	Z[3] = 0.04465499663169130187;
	Z[4] = 2.219775824563799962e-09;
	R[16] = Z[0]*Z[3]+Z[2]*Z[4]+Z[1]-Y[17];
	Z[1] = -0.04465497329256169882;
	R[17] = Z[0]*Z[4]+Z[1]-Z[2]*Z[3]-Y[18];
	Z[1] = fabs(Y[17]*Y[17]+Y[18]*Y[18]);
	R[18] = Y[19]-sqrt(Z[1]);
	Z[1] = Y[19]*Y[19]+0.00533651695611219545;
	R[19] = Y[16]-sqrt(Z[1]);
	Z[1] = 0.07526215029278779926;
	Z[3] = -0.0274739834837783004;
	Z[4] = 0.07179454623553609659;
	R[20] = Z[0]*Z[1]+Z[2]*Z[3]+Z[4]-Y[21];
	Z[4] = 0.03211993553327720254;
	R[21] = Z[0]*Z[3]+Z[4]-Z[1]*Z[2]-Y[22];
	Z[0] = fabs(Y[21]*Y[21]+Y[22]*Y[22]);
	R[22] = Y[23]-sqrt(Z[0]);
	Z[0] = Y[23]-0.02916969277103229945;
	Z[0] = Z[0]*Z[0]+0.00195901209279177268;
	R[23] = Y[20]-sqrt(Z[0]);
}

static void Jp(double T, double *Y, double *J)
{
	double Z[10];
	long ti1, ti2, ti3;

	for(ti2=0;ti2<=23;ti2++)
		for(ti3=0;ti3<=27;ti3++)
			J[ti2*28+ti3] = 0.;
	J[5] = -1.;
	Z[0] = sin(Y[26]);
	Z[1] = cos(Y[24]);
	Z[2] = cos(Y[26]);
	Z[3] = sin(Y[24]);
	Z[4] = Z[0]*Z[1]+Z[2]*Z[3];
	Z[5] = Z[1]*Z[2]-Z[0]*Z[3];
	Z[6] = 0.004258009264589300018*Z[5];
	Z[7] = -0.04715016227153790061*Z[4];
	J[24] = Z[6]+Z[7];
	Z[8] = -0.31*Z[0];
	J[26] = Z[6]+Z[7]+Z[8];
	J[34] = -1.;
	Z[6] = 0.004258009264589300018*Z[4];
	Z[7] = -0.04715016227153790061*Z[5];
	J[52] = Z[7]-Z[6];
	Z[9] = -0.31*Z[2];
	J[54] = Z[7]+Z[9]-Z[6];
	Z[6] = Y[5]*Y[5]+Y[6]*Y[6];
	Z[7] = fabs(Z[6]);
	Z[7] = (1.0/(sqrt(Z[7])));
	if( Z[6]>0. )
		Z[6] = 1.;
	else if( Z[6]<0. )
		Z[6] = -1.;
	else
		Z[6] = 0.;
	J[61] = -Z[7]*Y[5]*Z[6];
	J[62] = -Z[7]*Y[6]*Z[6];
	J[63] = 1.;
	J[88] = 1.;
	if( Y[7]-0.1876654718923540032>0. )
		ti1 = 1;
	else if( Y[7]<0.1876654718923540032 )
		ti1 = -1;
	else
		ti1 = 0;
	J[91] = -((double)ti1);
	J[113] = -1.;
	Z[6] = 0.01869724304842369895*Z[5];
	Z[7] = 0.01737446805143240149*Z[4];
	J[136] = Z[6]+Z[7];
	J[138] = Z[6]+Z[7]+Z[8];
	J[142] = -1.;
	Z[4] = 0.01869724304842369895*Z[4];
	Z[5] = 0.01737446805143240149*Z[5];
	J[164] = Z[5]-Z[4];
	J[166] = Z[5]+Z[9]-Z[4];
	Z[4] = Y[1]*Y[1]+Y[2]*Y[2];
	Z[5] = fabs(Z[4]);
	Z[5] = (1.0/(sqrt(Z[5])));
	if( Z[4]>0. )
		Z[4] = 1.;
	else if( Z[4]<0. )
		Z[4] = -1.;
	else
		Z[4] = 0.;
	J[169] = -Z[5]*Y[1]*Z[4];
	J[170] = -Z[5]*Y[2]*Z[4];
	J[171] = 1.;
	J[196] = 1.;
	Z[4] = Y[3]-0.1191861621963549957;
	Z[5] = Z[4]*Z[4]+0.000887894734126077383;
	J[199] = -(1.0/(sqrt(Z[5])))*Z[4];
	J[233] = -1.;
	J[248] = 0.01939984557043140074*Z[3]-0.0003627956121079530131*Z[1];
	J[262] = -1.;
	J[276] = 0.01939984557043140074*Z[1]+0.0003627956121079530131*Z[3];
	Z[4] = Y[9]*Y[9]+Y[10]*Y[10];
	Z[5] = fabs(Z[4]);
	Z[5] = (1.0/(sqrt(Z[5])));
	if( Z[4]>0. )
		Z[4] = 1.;
	else if( Z[4]<0. )
		Z[4] = -1.;
	else
		Z[4] = 0.;
	J[289] = -Z[5]*Y[9]*Z[4];
	J[290] = -Z[5]*Y[10]*Z[4];
	J[291] = 1.;
	J[316] = 1.;
	Z[4] = Y[11]-0.007207271244649430134;
	Z[5] = Z[4]*Z[4]+0.000215371568910646808;
	J[319] = -(1.0/(sqrt(Z[5])))*Z[4];
	J[349] = -1.;
	Z[4] = -0.04973713162428480153;
	J[360] = Z[3]*Z[4]+0.001781419218562789957*Z[1];
	J[378] = -1.;
	J[388] = Z[1]*Z[4]-0.001781419218562789957*Z[3];
	Z[1] = Y[13]*Y[13]+Y[14]*Y[14];
	Z[3] = fabs(Z[1]);
	Z[3] = (1.0/(sqrt(Z[3])));
	if( Z[1]>0. )
		Z[1] = 1.;
	else if( Z[1]<0. )
		Z[1] = -1.;
	else
		Z[1] = 0.;
	J[405] = -Z[3]*Y[13]*Z[1];
	J[406] = -Z[3]*Y[14]*Z[1];
	J[407] = 1.;
	J[432] = 1.;
	Z[1] = Y[15]-0.01811680735798800181;
	Z[3] = Z[1]*Z[1]+8.35663532754437087e-06;
	J[435] = -(1.0/(sqrt(Z[3])))*Z[1];
	J[465] = -1.;
	Z[1] = -0.04465499663169130187;
	J[474] = Z[0]*Z[1]+2.219775824563799962e-09*Z[2];
	J[494] = -1.;
	J[502] = Z[1]*Z[2]-2.219775824563799962e-09*Z[0];
	Z[1] = Y[17]*Y[17]+Y[18]*Y[18];
	Z[3] = fabs(Z[1]);
	Z[3] = (1.0/(sqrt(Z[3])));
	if( Z[1]>0. )
		Z[1] = 1.;
	else if( Z[1]<0. )
		Z[1] = -1.;
	else
		Z[1] = 0.;
	J[521] = -Z[3]*Y[17]*Z[1];
	J[522] = -Z[3]*Y[18]*Z[1];
	J[523] = 1.;
	J[548] = 1.;
	Z[1] = Y[19]*Y[19]+0.00533651695611219545;
	J[551] = -(1.0/(sqrt(Z[1])))*Y[19];
	J[581] = -1.;
	Z[1] = -0.07526215029278779926;
	J[586] = Z[0]*Z[1]-0.0274739834837783004*Z[2];
	J[610] = -1.;
	J[614] = Z[1]*Z[2]+0.0274739834837783004*Z[0];
	Z[0] = Y[21]*Y[21]+Y[22]*Y[22];
	Z[1] = fabs(Z[0]);
	Z[1] = (1.0/(sqrt(Z[1])));
	if( Z[0]>0. )
		Z[0] = 1.;
	else if( Z[0]<0. )
		Z[0] = -1.;
	else
		Z[0] = 0.;
	J[637] = -Z[1]*Y[21]*Z[0];
	J[638] = -Z[1]*Y[22]*Z[0];
	J[639] = 1.;
	J[664] = 1.;
	Z[0] = Y[23]-0.02916969277103229945;
	Z[1] = Z[0]*Z[0]+0.00195901209279177268;
	J[667] = -(1.0/(sqrt(Z[1])))*Z[0];
}

static void inpfn(double T, double *U)
{

}

/*
	Projection: Use Rp,Jp constraint residual and Jacobian functions to
	project the input solution x back onto the constraint manfold.

	Return codes:
	0 - Successful completion
	1 - Entry of Residual or Jacobian is undefined/infinity
	2 - Row of Jacobian is zero, but residual is nonzero
	3 - Iteration limit reached
*/
static long Projection(
	double t,		/* Current time */
	double *x,		/* Current solution (updated) */
	double tol,		/* Tolerance limit for iteration */
	long maxiter,	/* Max iteration limit */
	double *w		/* Weight vector */
)
{
	long i, j, k, r, c, iter, nc2, ip[NCON],per[NDIFF];
	double scl, resmag, val, val2, R[NCON],J[NCON*NDIFF],A[NCON*NCON];
#if NCON*NCON>NDIFF
	double iA[NCON*NCON];
#else
	double iA[NDIFF];
#endif

	for(iter=0;iter<maxiter;iter++) {

		/* Compute the Jacobian and Residual at the current solution */
		Rp(t, x, R);
		Jp(t, x, J);

		/* Scale the columns by the weight factor */
		if( w ) {
			for(j=0;j<NDIFF;j++)
				for(i=0;i<NCON;i++)
					J[NDIFF*i+j] /= w[j];
		}

		/* Rescale rows of Jacobian so that maximum coeff is 1, validating */
		resmag = 0.0;
		for(i=0;i<NCON;i++) {
			if( IS_UNDEF(R[i]) ) return(1);
			val = 0.0;
			for(j=0;j<NDIFF;j++) {
				if( IS_UNDEF(J[i*NDIFF+j]) ) return(1);
				val2 = fabs(J[i*NDIFF+j]);
				if( val2>val ) val = val2;
			}
			if( val==0. ) {
				if( R[i]!=0. )
					return(2);
			}
			else {
				val = 1.0/val;
				for(j=0;j<NDIFF;j++) J[i*NDIFF+j] *= val;
				R[i] *= val;
				resmag += R[i]*R[i];
			}
		}

		/* Compute J_hat from J
			The solving process will select the row with the largest residual,
			then choose the largest coeff, computing an approx.  of the condition
			as we go, stopping when the condition becomes too poor. */
		for(i=0;i<NDIFF;i++) per[i]=i;
		nc2 = NCON;
		scl = 1.0;
		i = 0;
		while( i<nc2 ) {
			/* Search for row with largest residual */
			resmag = fabs(R[i]); r = i;
			for(j=i+1;j<nc2;j++) {
				val2 = fabs(R[j]);
				if( val2>resmag ) { resmag = val2; r = j; }
			}
			/* Check for termination on the first row of this iteration */
			if( i==0 && ( resmag<=tol || iter>=maxiter )) {
				nc2 = NDIFF+1; break;
			}

			/* Row 'r' has largest residual 'val', locate column with
				largest coeff */
			val = fabs(J[r*NDIFF+i]); c = i;
			for(j=i+1;j<NDIFF;j++) {
				val2 = fabs(J[r*NDIFF+j]);
				if( val2>val ) { val = val2; c = j; }
			}

			if( scl*val<sqrt(tol) )  {
				/* Coefficient is too small - remove row */
				if( r!=nc2-1 ) {
					for(j=0;j<NDIFF;j++) J[r*NDIFF+j] = J[(nc2-1)*NDIFF+j];
					R[r] = R[nc2-1];
				}
				nc2--;
			}
			else {
				/* Adjust condition estimate */
				scl *= val;
				/* Row/Column exchanges */
				if( c!=i ) {
					for(j=0;j<nc2;j++) { val=J[j*NDIFF+i]; J[j*NDIFF+i]=J[j*NDIFF+c]; J[j*NDIFF+c]=val; }
					j=per[i]; per[i]=per[c]; per[c]=j;
				}
				if( r!=i ) {
					for(j=i;j<NDIFF;j++) { val=J[i*NDIFF+j]; J[i*NDIFF+j]=J[r*NDIFF+j]; J[r*NDIFF+j]=val; }
					val=R[i]; R[i]=R[r]; R[r]=val;
				}
				/* Rescale if necessary */
				if( J[i*NDIFF+i]!=1.0 ) {
					val = 1.0/J[i*NDIFF+i];
					J[i*NDIFF+i] = 1.0;
					for(j=i+1;j<NDIFF;j++) J[i*NDIFF+j] = J[i*NDIFF+j]*val;
					R[i] *= val;
				}
				/* Backsub */
				for(r=0;r<nc2;r++)
					if( r!=i && J[r*NDIFF+i]!=0.0 ) {
						for(c=i+1;c<NDIFF;c++) J[r*NDIFF+c] -= J[r*NDIFF+i]*J[i*NDIFF+c];
						R[r] -= J[r*NDIFF+i]*R[i];
						J[r*NDIFF+i] = 0.0;
					}
				if( i==NDIFF-1 ) {
					nc2=NDIFF;
					break;
				}
				else
					i++;
			}
		}
		if( nc2==NDIFF+1 )
			/* Termination: residual within bound on first row */
			break;

		/* Compute A = J_hat * J_hat^T */
		for(j=0;j<nc2;j++)
			for(i=0;i<=j;i++) {
				A[i*nc2+j] = 0.0;
				for(k=0;k<NDIFF;k++) A[i*nc2+j]+=J[i*NDIFF+k]*J[j*NDIFF+k];
			}
		for(i=0;i<nc2;i++)
			for(j=0;j<i;j++)
				A[i*nc2+j]=A[j*nc2+i];

		/* Construct (J_hat * J_hat^T)^(-1) in iA */
		for(i=0;i<nc2*nc2;i++) iA[i]=0.0;
		for(i=0;i<nc2;i++) iA[i*(1+nc2)]=1.0;
		DecompCInc(nc2, A, nc2, ip);
		MultiSolveCInc(nc2, A, nc2, ip, nc2, iA, nc2);

		/* Multiply iA (nc2 x nc2) with R (nc2 x 1) to A (nc2 x 1)
			A = (J_hat * J_hat^T)^(-1) * R */
		for(i=0;i<nc2;i++) {
			A[i] = 0.0;
			for(k=0;k<nc2;k++) A[i] += iA[i*nc2+k]*R[k];
		}

		/* Multiply J_hat^T (NDIFF x nc2) with A (nc2 x 1) to iA (NDIFF x 1)
			 iA = J_hat^T * (J_hat * J_hat^T)^(-1) * R */
		for(i=0;i<NDIFF;i++) {
			iA[i] = 0.0;
			for(k=0;k<nc2;k++) iA[i] += J[k*NDIFF+i]*A[k];
		}

		val=0.0; for(i=0;i<NDIFF;i++) val+=x[i]*x[i]; val=sqrt(val);
		val2=0.0; for(i=0;i<NDIFF;i++) val2+=iA[i]*iA[i]; val2=sqrt(val2);
		val = val2/((val>0.1*val2)?val:(0.1*val2));
		if( val>0.1 ) {
			/* Solution is very far off - Use relaxed */
			val2 = ( tol>0.1/val )?tol:(0.1/val);
			for(i=0;i<NDIFF;i++) x[per[i]]-=val2*iA[i];
		}
		else
			/* Direct newton */
			for(i=0;i<NDIFF;i++) x[per[i]]-=iA[i];
	}
	if( iter==maxiter ) return(3); else return(0);
}

/*
	ProjectInitial: Use weighted projection to find consistent initial
	data with fixed initial values.

	Return codes:
	0 - Successful completion
	2 - Projection not converging
	3 - Iteration limit reached
*/
static long ProjectInitial(
	double t,			/* t0 */
	double *x,			/* Current solution (updated) */
	double ptol,		/* Tolerance limit for iteration for projection */
	long pmaxiter,	/* Max iteration limit for projection */
	long *icmask,	/* Fixed IC mask vector */
	double tol,		/* Convergence tolerance */
	long maxiter,	/* Max limit for number of calls to projection */
	double W			/* Default fixed IC weight */
)
{
	long i, ip, iter;
	double delta1, delta2, rate, val, w[NDIFF], ic[NDIFF];

	for(i=0;i<NDIFF;i++) {
		if( icmask[i]==0 )
			w[i] = 1.0;
		else {
			w[i] = W;
			ic[i] = x[i];
		}
	}

	delta1 = 1.0;
	for(iter=0;iter<maxiter;iter++) {
		/* Do weighted projection and check fixed IC deviation */
		ip=Projection(t,x,ptol,pmaxiter,w);
		if( ip>0 && ip!=3 ) return(2);

		delta2 = 0.0;
		for(i=0;i<NDIFF;i++)
			if( w[i]!=1.0 ) {
				val = 0.5*(fabs(x[i])+fabs(ic[i]));
				val = ( val > 1.0e-3 ) ? val : 1.0e-3;
				delta2+=fabs((x[i]-ic[i]))/(val);
			}

		/* Return if projection converged */
		if( delta2<=tol ) break;
		/* Check for adequate convergence rate */
		if( iter>2 && (delta2/delta1 > 0.9) ) return(2);
		/* Check iteration limit */
		if( iter==maxiter-1 ) { iter++; break; }

		/* Overwrite the solution vector with fixed IC values,
		   for next pass. */
		for(i=0;i<NDIFF;i++)
			if( w[i]!=1.0 ) x[i]=ic[i];

		delta1 = delta2;
	}
	/* Check iteration limit */
	if( iter==maxiter ) return(3); else return(0);
}

static void SolverUpdate(double *u, long internal, SolverStruct *S)
{
	long i;

	inpfn(S->w[0],u);
	for(i=0;i<NINP;i++) S->w[i+NDIFF+NIX1-NINP+1]=u[i];
	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
		SolverError(S,0,"index-1 and derivative evaluation failure");
		return;
	}
	if(internal) return;
	i=Projection(S->w[0],&S->w[1],CONTOL,CONITER,NULL);
	if(i>0 && i!=3) {
		SolverError(S,0,"constraint projection failure");
		return;
	}
	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
		SolverError(S,0,"index-1 and derivative evaluation failure");
		return;
	}
}

static void SolverOutputs(double *y, SolverStruct *S)
{
	otp(S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	y[ 0]=S->w[25];
	y[ 1]=S->w[26];
	y[ 2]=S->w[27];
	y[ 3]=S->w[28];
	y[ 4]=S->w[67];
	y[ 5]=S->w[68];
	y[ 6]=S->w[69];
	y[ 7]=S->w[70];
	y[ 8]=S->w[71];
	y[ 9]=S->w[72];
	y[10]=S->w[73];
	y[11]=S->w[74];
	y[12]=S->w[75];
	y[13]=S->w[61];
	y[14]=S->w[62];
	y[15]=S->w[63];
	y[16]=S->w[64];
	y[17]=S->w[65];
	y[18]=S->w[66];
}

static void RK4Step(double *u, SolverStruct *S)
{
	long i;
	double y[NEQ+1],yp1[NDFA],yp2[NDFA],yp3[NDFA];

	for(i=0;i<NEQ+1;i++) y[i]=S->w[i];
	for(i=0;i<NDIFF;i++) yp1[i]=S->w[1+NEQ+NPAR+i];
	S->w[0]+=0.5*S->h;
	for(i=0;i<NDIFF;i++) S->w[i+1]+=0.5*S->h*S->w[1+NEQ+NPAR+i];
	SolverUpdate(u,1,S);
	for(i=0;i<NDIFF;i++) yp2[i]=S->w[1+NEQ+NPAR+i];
	for(i=0;i<NDIFF;i++) S->w[i+1]=y[i+1]+0.5*S->h*S->w[1+NEQ+NPAR+i];
	SolverUpdate(u,1,S);
	for(i=0;i<NDIFF;i++) yp3[i]=S->w[1+NEQ+NPAR+i];
	S->w[0]=y[0]+S->h;
	for(i=0;i<NDIFF;i++) S->w[i+1]=y[i+1]+S->h*S->w[1+NEQ+NPAR+i];
	SolverUpdate(u,1,S);
	for(i=0;i<NDIFF;i++) S->w[i+1]=y[i+1]+S->h/6.0*(yp1[i]+2.0*(yp2[i]+yp3[i])+S->w[1+NEQ+NPAR+i]);
	SolverUpdate(u,0,S);
}

static void SolverSetup(double t0, double *ic, double *u, double *p, double *y, double h, SolverStruct *S)
{
	long i;

	S->h = h;
	S->iw=NULL;
	S->w[0] = t0;
	S->w[1] =  2.35073902498712712e-01;
	S->w[2] =  2.90089462295669120e-01;
	S->w[3] = -2.00021006373980403e-01;
	S->w[4] =  3.52363873184880272e-01;
	S->w[5] =  8.49620652792213992e-02;
	S->w[6] =  2.34003578656275718e-01;
	S->w[7] = -1.39886022176252150e-01;
	S->w[8] =  2.72627537171575396e-01;
	S->w[9] =  1.09034718284621398e-01;
	S->w[10] =  1.14419080116945585e-01;
	S->w[11] =  1.38130875792650022e-02;
	S->w[12] =  1.15249847215866008e-01;
	S->w[13] =  5.81720357126217225e-02;
	S->w[14] =  6.62824709612821195e-02;
	S->w[15] = -3.76252684726530868e-02;
	S->w[16] =  7.62169717607071445e-02;
	S->w[17] =  1.06389471559166268e-01;
	S->w[18] =  3.86723603790508978e-02;
	S->w[19] = -6.69824696860250868e-02;
	S->w[20] =  7.73447005458451215e-02;
	S->w[21] =  1.07078708234858626e-01;
	S->w[22] =  1.23236488590643609e-01;
	S->w[23] = -2.93043072532227916e-02;
	S->w[24] =  1.26672706388326284e-01;
	S->w[25] =  2.35619449019234484e+00;
	S->w[26] =  0.00000000000000000e+00;
	S->w[27] =  5.23598775598298927e-01;
	S->w[28] =  0.00000000000000000e+00;
	S->w[29] =  2.50000000000000000e-01;
	S->w[30] =  4.02180892451168503e-01;
	S->w[31] =  1.00000000000000000e+00;
	S->w[32] =  0.00000000000000000e+00;
	S->w[33] =  0.00000000000000000e+00;
	S->w[34] =  2.50000000000000000e-01;
	S->w[35] =  7.71678985927859884e-01;
	S->w[36] =  1.00000000000000000e+00;
	S->w[37] =  0.00000000000000000e-01;
	S->w[38] =  0.00000000000000000e+00;
	S->w[39] =  2.50000000000000000e-01;
	S->w[40] =  9.99981134551860218e-01;
	S->w[41] =  1.00000000000000000e+00;
	S->w[42] =  0.00000000000000000e+00;
	S->w[43] =  0.00000000000000000e+00;
	S->w[44] =  3.25000000000000012e-01;
	S->w[45] =  5.69508082751014832e-01;
	S->w[46] =  1.00000000000000000e+00;
	S->w[47] =  0.00000000000000000e+00;
	S->w[48] = -8.26063179990873806e+01;
	S->w[49] =  2.50000000000000000e-01;
	S->w[50] =  5.54688642609677096e-01;
	S->w[51] =  1.00000000000000000e+00;
	S->w[52] =  0.00000000000000000e+00;
	S->w[53] =  0.00000000000000000e+00;
	S->w[54] =  2.50000000000000000e-01;
	S->w[55] =  9.74345573616116178e-01;
	S->w[56] =  1.00000000000000000e+00;
	S->w[57] =  0.00000000000000000e-01;
	S->w[58] =  0.00000000000000000e+00;
	S->w[59] =  5.47929302664889520e+01;
	S->w[60] = -3.55491123360861660e+00;
	S->w[61] =  0.00000000000000000e+00;
	S->w[62] =  0.00000000000000000e+00;
	S->w[63] =  0.00000000000000000e+00;
	S->w[64] =  8.26063179990873806e+01;
	S->w[65] =  0.00000000000000000e+00;
	S->w[66] =  0.00000000000000000e+00;
	S->w[67] = -1.77817022617111392e+01;
	S->w[68] =  0.00000000000000000e+00;
	S->w[69] = -3.95785631286252126e+00;
	S->w[70] =  0.00000000000000000e+00;
	S->w[71] =  0.00000000000000000e+00;
	S->w[72] =  0.00000000000000000e-01;
	S->w[73] =  2.42998475334857078e-01;
	S->w[74] =  0.00000000000000000e+00;
	S->w[75] = -5.99469057651072710e-02;
	S->w[76] =  0.00000000000000000e+00;
	S->w[77] =  0.00000000000000000e+00;
	S->w[78] =  0.00000000000000000e+00;
	S->w[79] =  0.00000000000000000e+00;
	S->w[80] =  0.00000000000000000e+00;
	S->w[81] =  1.00000000000000004e-01;
	S->w[82] =  0.00000000000000000e+00;
	S->w[83] =  0.00000000000000000e+00;
	S->w[84] =  1.00000000000000000e+00;
	S->w[85] =  1.00000000000000000e+00;

	for(i=0;i<NDIFF;i++) S->w[i+NEQ+NPAR+1]=0.0;

	inpfn(S->w[0],u);
	for(i=0;i<NINP;i++) S->w[i+NDIFF+NIX1-NINP+1]=u[i];
	if(ic) for(i=0;i<NDIFF;i++) if(!IS_UNDEF(ic[i])) S->w[i+1]=ic[i];
	if(p) for(i=0;i<NPAR;i++) S->w[i+NEQ+1]=p[i];
	S->w[NEQ+NPAR+1]=0.0;
	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
		SolverError(S,0,"index-1 and derivative evaluation failure");
		return;
	}
#if INITCONITER>0
	i=ProjectInitial(S->w[0],&S->w[1],INITCONTOL,INITCONITER,icmask,INITTOL,INITITER,INITWEIGHT);
	if(i>0 && i!=3) {
		SolverError(S,0,"constraint projection failure");
		return;
	}
	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
		SolverError(S,0,"index-1 and derivative evaluation failure");
		return;
	}
#endif
	SolverOutputs(y,S);
}

/*
	Parametrized simulation driver
*/
EXP long M_DECL ParamDriverMC(double t0, double dt, long npts, long stepsperpt, double *ic, double *p, double *out, char *errbuf, long internal)
{
	double u[NINP],y[NOUT+1],w[1+2*NEQ+NPAR+NDFA+NEVT];
	long i,j;
#ifdef FROM_MAPLE
	long ictr=0,pct=0;
	char buf[200];
#endif
	SolverStruct S;

	/* Setup */
	for(i=0;i<npts*(NOUT+1);i++) out[i]=*dsn_undef;
	S.w=w;
	if(internal==0) S.err=0; else S.err=-1;
	S.buf=errbuf;
	SolverSetup(t0,ic,u,p,y,dt,&S);
	/* Output */
	out[0]=t0; for(j=0;j<NOUT;j++) out[j+1]=y[j];
	/* Integration loop */
	for(i=1;i<npts;i++) {
		for(j=0;j<stepsperpt;j++) {
			/* Take a step with states */
			RK4Step(u,&S);
			if( S.err>0 ) break;
#ifdef FROM_MAPLE
			ictr++;
			if(ictr>=500) {
				if( kv->getInterruptValue() ) return(i);
				ictr=0;
			}
#endif
		}
#ifdef FROM_MAPLE
		j=(100*i)/(npts-1);
		if(j>pct) {
			pct=j;
			sprintf(buf,"ProgressUpdate: %li %f",(long)pct,S.w[0]);
			kv->userinfo(1,"MapleSimProgressUpdate",buf);
		}
#endif
		/* Output */
		SolverOutputs(y,&S);
		out[i*(NOUT+1)]=S.w[0]; for(j=0;j<NOUT;j++) out[i*(NOUT+1)+j+1]=y[j];
	}
#ifdef _SOLVER_TERMINATE
	if(i==npts)
		SolverTerminate(&S);
#endif

	return(i);
}

/*
	Old interface - maintain for backward compatibility
*/
EXP long M_DECL ParamDriverC(double t0, double dt, long npts, double *ic, double *p, double *out, char *errbuf, long internal)
{
	return ParamDriverMC(t0,dt,npts,1,ic,p,out,errbuf,internal);
}

#ifdef FROM_MAPLE
EXP ALGEB M_DECL ParamDriver( MKernelVector kv_in, ALGEB *args )
{
	double t0,tf,dt,*ic,*p,*out;
	M_INT nargs,bounds[4],npts,naout,stepsperpt,sppa=0,i;
	RTableSettings s;
	ALGEB outd;
	char buf[1000];

	kv=kv_in;
	nargs=kv->numArgs((ALGEB)args);
	if( nargs<5 || nargs>7 )
		kv->error("incorrect number of arguments");

	/* Process time vals */
	if( !kv->isNumeric(args[1]) )
		kv->error("argument #1, the initial time, must be numeric");
	t0=kv->mapleToFloat64(args[1]);
	if( !kv->isNumeric(args[2]) )
		kv->error("argument #2, the final time, must be numeric");
	tf=kv->mapleToFloat64(args[2]);
	if( t0>=tf )
		kv->error("the final time must be larger than the initial time");
	if( !kv->isNumeric(args[3]) )
		kv->error("argument #3, the time step, must be a positive numeric value");
	dt=kv->mapleToFloat64(args[3]);
	if(dt<=0)
		kv->error("argument #3, the time step, must be a positive numeric value");

	/* Check for presence of stepsperpt argument */
	if( kv->isInteger(args[4]) && (stepsperpt=kv->mapleToInteger32(args[4]))>0 )
		sppa=1;
	else
		stepsperpt=1;
	npts=(M_INT)floor((tf+1e-10*dt-t0)/(stepsperpt*dt))+1;

	/* Processing ic in */
	if( NDIFF==0 )
		ic=NULL;
	else if( kv->isInteger(args[4+sppa]) && kv->mapleToInteger32(args[4+sppa])==0 )
		ic=NULL;
	else if( !kv->isRTable(args[4+sppa]) ) {
		ic=NULL;
		kv->error("argument #%1, the initial data, must be a 1..ndiff rtable",kv->toMapleInteger(4+sppa));
	}
	else {
		kv->rtableGetSettings(&s,args[4+sppa]);
		if( s.storage != RTABLE_RECT || s.data_type != RTABLE_FLOAT64 ||
			 s.num_dimensions != 1 || kv->rtableLowerBound(args[4+sppa],1)!=1 ||
			 kv->rtableUpperBound(args[4+sppa],1) != NDIFF )
			kv->error("argument #%1, the initial data, must be a 1..ndiff rtable",kv->toMapleInteger(4+sppa));
		ic=(double *)kv->rtableData(args[4+sppa]);
	}

	/* Processing parameters in */
	if( NPAR==0 )
		p=NULL;
	else if( kv->isInteger(args[5+sppa]) && kv->mapleToInteger32(args[5+sppa])==0 )
		p=NULL;
	else if( !kv->isRTable(args[5+sppa]) ) {
		p=NULL;
		kv->error("argument #%1, the parameter data, must be a 1..npar rtable",kv->toMapleInteger(5+sppa));
	}
	else {
		kv->rtableGetSettings(&s,args[5+sppa]);
		if( s.storage != RTABLE_RECT || s.data_type != RTABLE_FLOAT64 ||
			 s.num_dimensions != 1 || kv->rtableLowerBound(args[5+sppa],1)!=1 ||
			 kv->rtableUpperBound(args[5+sppa],1) != NPAR )
			kv->error("argument #%1, the parameter data, must be a 1..npar rtable",kv->toMapleInteger(5+sppa));
		p=(double *)kv->rtableData(args[5+sppa]);
	}

	/* Output data table */
	if( nargs==6+sppa ) {
		outd=NULL;
		if( !kv->isRTable(args[6+sppa]) ) {
			out=NULL;
			naout=0;
			kv->error("argument #%1, the output data, must be a 1..npts,1..nout+1 C_order rtable",kv->toMapleInteger(6+sppa));
		}
		else {
			kv->rtableGetSettings(&s,args[6+sppa]);
			if( s.storage != RTABLE_RECT || s.data_type != RTABLE_FLOAT64 ||
			 	s.order != RTABLE_C || s.num_dimensions != 2 ||
			 	kv->rtableLowerBound(args[6+sppa],1)!=1 ||
			 	kv->rtableLowerBound(args[6+sppa],2)!=1 ||
			 	kv->rtableUpperBound(args[6+sppa],2) != NOUT+1 )
				kv->error("argument #%1, the output data, must be a 1..npts,1..nout+1 C_order rtable",kv->toMapleInteger(6+sppa));
			naout=kv->rtableUpperBound(args[6+sppa],1);
			if( naout<1 )
				kv->error("argument #%1, the output data, must have at least 1 output slot",kv->toMapleInteger(6+sppa));
			out=(double *)kv->rtableData(args[6+sppa]);
			if(naout<npts) npts=naout;
		}
	}
	else {
		kv->rtableGetDefaults(&s);
		bounds[0]=1; bounds[1]=npts;
		bounds[2]=1; bounds[3]=NOUT+1;
		s.storage=RTABLE_RECT;
		s.data_type=RTABLE_FLOAT64;
		s.order=RTABLE_C;
		s.num_dimensions=2;
		s.subtype=RTABLE_ARRAY;
		outd=kv->rtableCreate(&s,NULL,bounds);
		out=(double *)kv->rtableData(outd);
		naout=npts;
	}
	for(i=0;i<naout*(NOUT+1);i++) out[i]=*dsn_undef;

	i=ParamDriverMC(t0,dt,npts,stepsperpt,ic,p,out,buf,1);

	/* All done */
	if(outd==NULL)
		return(kv->toMapleInteger(i));
	else
		return(outd);
}
#endif
