/***************************************************
 * Automatically generated by Maple.
 * Created On: Mon Jul 31 16:54:51 2023.
***************************************************/
#ifdef WMI_WINNT
#define EXP __declspec(dllexport)
#else
#ifdef X86_64_WINDOWS
#define EXP __declspec(dllexport)
#else
#define EXP
#endif
#endif
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#ifdef FROM_MAPLE
#include <mplshlib.h>
static MKernelVector kv;
EXP ALGEB M_DECL SetKernelVector(MKernelVector kv_in, ALGEB args) { ((void)(args)); kv=kv_in; return(kv->toMapleNULL()); }
#include <string.h>
#else
#include <string.h>
#include <stdarg.h>

#define MAXSTRINGLENGTH 1000
#define MAXNUMPART 20


void toMapleError(char *msg, ...)
{
	char fcpy[MAXSTRINGLENGTH+1],*offs[MAXNUMPART+1],
		*msg_pars[MAXNUMPART+1],res_str[MAXSTRINGLENGTH+1];
	int argref[MAXNUMPART],maxargref,npart,v,i,j,res_len;
	va_list argptr;

	if(strlen(msg)>MAXSTRINGLENGTH)
		strcpy(fcpy,"message string is too long");
	else
		strcpy(fcpy,msg);

	maxargref=0;
	npart=0;
	i=0;
	offs[npart]=&fcpy[i];
	for(j=0;fcpy[j]!='\0';j++)
		if(fcpy[j]=='%' && fcpy[j+1]!='%') {
			fcpy[j++]='\0';
			if(fcpy[j]=='-') j++;
			if(fcpy[j]=='\0') break;
			v=0;
			while(fcpy[j]>='0' && fcpy[j]<='9') v=10*v+(fcpy[j++]-'0');
			argref[npart]=v;
			if(v>maxargref) maxargref=v;
			i=j;
			npart++;
			offs[npart]=&fcpy[i];
		}

	va_start(argptr,msg);
	for(i=0;i<maxargref;i++) msg_pars[i] = va_arg(argptr, char*);
	va_end(argptr);

	strcpy(res_str,offs[0]);
	res_len=strlen(res_str);
	for(i=0;i<npart;i++) {
		res_len+=strlen(msg_pars[argref[i]-1]);
		if(res_len>MAXSTRINGLENGTH) {
			strcpy(res_str,"message string is too long");
			break;
		}
		else
			strcat(res_str,msg_pars[argref[i]-1]);

		res_len+=strlen(offs[i+1]);
		if(res_len>MAXSTRINGLENGTH) {
			strcpy(res_str,"message string is too long");
			break;
		}
		else
			strcat(res_str,offs[i+1]);
	}
	for(i=0;i<maxargref;i++) free(msg_pars[i]);
	fprintf(stderr,"Error: %s\n",res_str);
}

char* toMapleInteger(int i)
{
	char *str=(char *)malloc(21);
	sprintf(str,"%li",(long)i);
	return(str);
}

char* toMapleFloat(double f)
{
	char *str=(char *)malloc(20);
	sprintf(str,"%f",f);
	return(str);
}

char* toMapleString(const char *s)
{
	char *str=(char *)malloc(strlen(s)+1);
	strcpy(str,s);
	return(str);
}

char* toMapleBoolean(int b)
{
	char *str=(char *)malloc(6);
	switch(b) {
	case 0:
		strcpy(str,"false");
	default:
		strcpy(str,"true");
	return(str);
	}
}

void toMapleUserinfo(int level, char *name, char *msg)
{
	printf("Info: %s:%s\n",name,msg);
}

typedef struct MKernelVectorDesc {
    void (*error)(char *msg, /* char *par1, *par2, */ ...);
	char* (*toMapleInteger)(int i);
	char* (*toMapleFloat)(double f);
	char* (*toMapleString)(const char *s);
	char* (*toMapleBoolean)(int b);
	void (*userinfo)(int level, char *name, char *msg);
} MKernelVectorDesc, *MKernelVector;

MKernelVectorDesc mykv = {
	&toMapleError,
	&toMapleInteger,
	&toMapleFloat,
	&toMapleString,
	&toMapleBoolean,
	&toMapleUserinfo
};

MKernelVector kv= &mykv;
#ifdef WMI_WINNT
#define M_DECL __stdcall
#else
#define M_DECL
#endif
#endif

/***************************************************
* Variable Definition for System:

* State variable(s):
*    x[ 0] = `Main.PlanarArmAndRobot.MuscleArm1.BiExtensor.activationDynamics1.a`(t)
*    x[ 1] = `Main.PlanarArmAndRobot.MuscleArm1.BiFlexor.activationDynamics1.a`(t)
*    x[ 2] = `Main.PlanarArmAndRobot.MuscleArm1.ElbowExtensor.activationDynamics1.a`(t)
*    x[ 3] = `Main.PlanarArmAndRobot.MuscleArm1.ElbowFlexor.activationDynamics1.a`(t)
*    x[ 4] = `Main.PlanarArmAndRobot.MuscleArm1.ShoulderExtensor.activationDynamics1.a`(t)
*    x[ 5] = `Main.PlanarArmAndRobot.MuscleArm1.ShoulderFlexor.activationDynamics1.a`(t)
*    x[ 6] = `Main.PlanarArmAndRobot.MuscleArm1.zElbow.theta`(t)
*    x[ 7] = diff(`Main.PlanarArmAndRobot.MuscleArm1.zElbow.theta`(t),t)
*    x[ 8] = `Main.PlanarArmAndRobot.MuscleArm1.zShoulder.theta`(t)
*    x[ 9] = diff(`Main.PlanarArmAndRobot.MuscleArm1.zShoulder.theta`(t),t)
*    x[10] = `Main.PlanarArmAndRobot.R1.theta`(t)
*    x[11] = diff(`Main.PlanarArmAndRobot.R1.theta`(t),t)
*    x[12] = `Main.PlanarArmAndRobot.robot.R1.theta`(t)
*    x[13] = diff(`Main.PlanarArmAndRobot.robot.R1.theta`(t),t)
*    x[14] = `Main.PlanarArmAndRobot.robot.R2.flange_b_phiMB`(t)
*    x[15] = diff(`Main.PlanarArmAndRobot.robot.R2.flange_b_phiMB`(t),t)
*
* Output variable(s):
*    y[ 0] = `Main.PlanarArmAndRobot.MuscleArm1.zElbow.theta`(t)
*    y[ 1] = diff(`Main.PlanarArmAndRobot.MuscleArm1.zElbow.theta`(t),t)
*    y[ 2] = `Main.PlanarArmAndRobot.MuscleArm1.zShoulder.theta`(t)
*    y[ 3] = diff(`Main.PlanarArmAndRobot.MuscleArm1.zShoulder.theta`(t),t)
*    y[ 4] = `Main.PlanarArmAndRobot.axyz[1]`(t)
*    y[ 5] = `Main.PlanarArmAndRobot.axyz[2]`(t)
*    y[ 6] = `Main.PlanarArmAndRobot.axyz[3]`(t)
*    y[ 7] = `Main.PlanarArmAndRobot.vxyz[1]`(t)
*    y[ 8] = `Main.PlanarArmAndRobot.vxyz[2]`(t)
*    y[ 9] = `Main.PlanarArmAndRobot.vxyz[3]`(t)
*    y[10] = `Main.PlanarArmAndRobot.xyz[1]`(t)
*    y[11] = `Main.PlanarArmAndRobot.xyz[2]`(t)
*    y[12] = `Main.PlanarArmAndRobot.xyz[3]`(t)
*    y[13] = `Main.PlanarArmAndRobot.FBiExt`(t)
*    y[14] = `Main.PlanarArmAndRobot.FBiFlex`(t)
*    y[15] = `Main.PlanarArmAndRobot.FElExt`(t)
*    y[16] = `Main.PlanarArmAndRobot.FElFlex`(t)
*    y[17] = `Main.PlanarArmAndRobot.FShExt`(t)
*    y[18] = `Main.PlanarArmAndRobot.FShFlex`(t)
*    y[19] = `Main.PlanarArmAndRobot.eeAcc[1]`(t)
*    y[20] = `Main.PlanarArmAndRobot.eeAcc[2]`(t)
*    y[21] = `Main.PlanarArmAndRobot.eeAcc[3]`(t)
*    y[22] = `Main.PlanarArmAndRobot.eePos[1]`(t)
*    y[23] = `Main.PlanarArmAndRobot.eePos[2]`(t)
*    y[24] = `Main.PlanarArmAndRobot.eePos[3]`(t)
*    y[25] = `Main.PlanarArmAndRobot.eeVel[1]`(t)
*    y[26] = `Main.PlanarArmAndRobot.eeVel[2]`(t)
*    y[27] = `Main.PlanarArmAndRobot.eeVel[3]`(t)
*    y[28] = `Main.PlanarArmAndRobot.robot.R1.theta`(t)
*    y[29] = diff(`Main.PlanarArmAndRobot.robot.R1.theta`(t),t)
*    y[30] = `Main.PlanarArmAndRobot.robot.R2.flange_b_phiMB`(t)
*    y[31] = diff(`Main.PlanarArmAndRobot.robot.R2.flange_b_phiMB`(t),t)
*
* Input variable(s):
*    u[ 0] = `Main.PlanarArmAndRobot.Fx`(t)
*    u[ 1] = `Main.PlanarArmAndRobot.Fz`(t)
*    u[ 2] = `Main.PlanarArmAndRobot.uBiExt`(t)
*    u[ 3] = `Main.PlanarArmAndRobot.uBiFlex`(t)
*    u[ 4] = `Main.PlanarArmAndRobot.uElExt`(t)
*    u[ 5] = `Main.PlanarArmAndRobot.uElFlex`(t)
*    u[ 6] = `Main.PlanarArmAndRobot.uShExt`(t)
*    u[ 7] = `Main.PlanarArmAndRobot.uShFlex`(t)
*    u[ 8] = `Main.PlanarArmAndRobot.torque1`(t)
*    u[ 9] = `Main.PlanarArmAndRobot.torque2`(t)
*
* Parameter(s):
*    p[ 0] = `Main.PlanarArmAndRobot.KdEl` (default = 1.)
*    p[ 1] = `Main.PlanarArmAndRobot.KdSh` (default = 1.)
*
************************************************/

/* Set up fixed initial condition mask */
int icmask[16] = {
	0,0,0,0,0,0,1,1,1,1,
	0,0,0,0,0,0};

/* Set up visible initial condition mask */
int icvis[16] = {
	1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1};

/* Configurable parameters */
#define CONITER 3
#define CONTOL 1.000000e-05
#define INITCONITER 100
#define INITCONTOL 1.000000e-10
#define INITITER 50
#define INITTOL 1.000000e-08
#define INITWEIGHT 2.000000e+01
#define INCONTOL 1e200

/* Wordsize integer definition */
#ifndef M_INT
# if defined _MINGW64 || defined X86_64_WINDOWS
#  define M_INT long long
# elif defined __x86_64__ || defined __ppc64__
#  define M_INT long
# elif defined _M_X64
#  define M_INT long long
# else
#  define M_INT long
# endif
#endif

/* Fixed parameters */
#define NDIFF 16
#define NDFA 16
#define NSDIFF 16
#define NEQ 80
#define NPAR 2
#define NINP 10
#define NDISC 0
#define NIX1 64
#define NOUT 32
#define NCON 6
#define NEVT 0
#ifdef EVTHYST
#define NZC 2*NEVT
#else
#define NZC NEVT
#endif

typedef struct {
	double h;		/* Integration step size */
	double *w;		/* Float workspace */
	int *iw;		/* Integer workspace */
	int err;			/* Error flag */
	char *buf;		/* Error message */
	double py[NOUT];
} SolverStruct;

static void SolverError(SolverStruct *S, int term, char *errmsg)
{
#ifdef FROM_MAPLE
	int i;
#endif
	if(term)
		sprintf(S->buf,"Simulation terminated at t=%20.16e: %s\n",S->w[0],errmsg);
	else
		sprintf(S->buf,"Error at t=%20.16e: %s\n",S->w[0],errmsg);
#ifdef FROM_MAPLE
	for(i=0;S->buf[i]!='\0';i++);
	S->buf[i-1]='\0';
	if(S->err==-1) kv->error(S->buf);
#endif
	S->err=1;
}

static double dsn_zero=0.0;
static unsigned char dsn_undefC[8] = { 0, 0, 0, 0, 0, 0, 0xF8, 0x7F };
static double *dsn_undef = (double *)&dsn_undefC;
static unsigned char dsn_posinfC[8] = { 0, 0, 0, 0, 0, 0, 0xF0, 0x7F };
static double *dsn_posinf = (double *)&dsn_posinfC;
static unsigned char dsn_neginfC[8] = { 0, 0, 0, 0, 0, 0, 0xF0, 0xFF };
static double *dsn_neginf = (double *)&dsn_neginfC;
#define trunc(v) ( (v>0.0) ? floor(v) : ceil(v) )
#define IS_UNDEF(a) (a-a!=0. || (a!=0. && a-2.*a==0.))
#define UNUSED(a) ((void)(a))
double avoidcompilerwarn() { return(dsn_zero+*dsn_undef+*dsn_posinf+*dsn_neginf); }
#ifndef M_INT
# if defined _MINGW64 || defined X86_64_WINDOWS
#  define M_INT long long
# elif defined __x86_64__ || defined __ppc64__
#  define M_INT long
# elif defined _M_X64
#  define M_INT long long
# else
#  define M_INT long
# endif
#endif


#ifdef MSVC
#pragma optimize( "gty", on)
#endif
#ifndef INCONTOL
#define INCONTOL 1e-14
#endif

static void LSQDecompSolve(M_INT n, double *A, M_INT Ainc, M_INT *ip, double *b)
{
	M_INT i,j,k,r,c,lsq,cp;
	double s,t;

	for(i=0;i<n;i++) {
		if(b[i]-b[i]!=0.0 || (b[i]!=0. && b[i]-2.*b[i]==0.)) { ip[n-1]=0; A[0]=1.; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
		t = fabs(A[i*Ainc]);
		for(j=1;j<n;j++) {
			s = fabs(A[i*Ainc+j]);
			if(s>t) t = s;
		}
		if( t==0.0 )
			A[i*Ainc+n] = 1.0;
		else {
			t = 1.0/t;
			for(j=0;j<n;j++) A[i*Ainc+j] *= t;
			b[i] *= t;
			A[i*Ainc+n] = t;
		}
	}

	for(j=0;j<n;j++) {
		t = fabs(A[j]);
		for(i=1;i<n;i++) {
			s = fabs(A[i*Ainc+j]);
			if(s>t) t = s;
		}
		if( t==0.0 )
			A[n*Ainc+j] = 1.0;
		else {
			t = 1.0/t;
			for(i=0;i<n;i++) A[i*Ainc+j] *= t;
			A[n*Ainc+j] = t;
		}
	}

	ip[n-1] = 0;
	lsq = 0;
	cp = 0;
	for(k=0;k<n;k++) {
		r = 0; c = 0; t = 0.0;
		if( cp<n ) {
			for(cp=cp+1;cp<n;cp++) {
				for(i=k;i<n;i++) {
					s = fabs(A[i*Ainc+cp]);
					if(s>t) { r = i; c = cp; t = s; }
				}
				if( t>0.5 ) break;
			}
		}
		if( cp>=n ) {
			for(i=k;i<n;i++)
				for(j=k;j<n;j++) {
					s = fabs(A[i*Ainc+j]);
					if(s>t) { r = i; c = j; t = s; }
				}
		}
		if( t<1e-10 ) {
			if( k==0 ) { ip[n-1]=0; A[0]=2.; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
			if( lsq ) { ip[n-1]=0; A[0]=3.; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
			lsq = 1;
			t = 1e-16;
			for(i=0;i<k;i++) {
				s = fabs(b[i]);
				if(s>t) t = s;
			}
			for(i=k;i<n;i++) {
				if( fabs(b[i])/t>INCONTOL*n ) { ip[n-1]=0; A[0]=4.; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
				b[i] = 0.0;
			}

			for(r=k;r<n;r++) {
				for(i=k;i<n;i++) A[i*Ainc+n+r] = 0.0;
				A[r*Ainc+n+r] = 1.0;
				A[(k-1)*Ainc+n+r] = -A[(k-1)*Ainc+r]/A[(k-1)*Ainc+k-1];
				for(i=k-1;i>=0;i--) {
					A[i*Ainc+n+r] = A[i*Ainc+r];
					for(j=i+1;j<k;j++)
						A[i*Ainc+n+r] += A[i*Ainc+j]*A[j*Ainc+n+r];
					A[i*Ainc+n+r] = -A[i*Ainc+n+r]/A[i*(Ainc+1)];
				}
			}
			for(r=0;r<k;r++) {
				s = -1.0/A[r*(Ainc+1)];
				for(i=k;i<n;i++)
					if( A[r*Ainc+n+i]!=0.0 ) {
						t = s*A[r*Ainc+n+i];
						A[i*Ainc+r] += t;
						for(j=r+1;j<n;j++)
							A[j*Ainc+n+i] += t*A[r*Ainc+j];
						b[i] += t*b[r];
					}
			}
			for(i=k;i<n;i++)
				for(j=k;j<n;j++)
					A[i*Ainc+j] = A[j*Ainc+n+i];
			r = 0; c = 0; t = 0.0;
			for(i=k;i<n;i++)
				for(j=k;j<n;j++) {
					s = fabs(A[i*Ainc+j]);
					if(s>t) { r = i; c = j; t = s; }
				}
			if( t<1e-10 ) { ip[n-1]=0; A[0]=3.; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
		}
		if( !lsq ) ip[n-1]++;
		if( k==n-1 ) break;
		ip[k] = r;
		ip[n+k] = c;
		if( r>k ) {
			for(j=0;j<n;j++) {
				t = A[r*Ainc+j]; A[r*Ainc+j] = A[k*Ainc+j]; A[k*Ainc+j] = t;
			}
			t = b[r]; b[r] = b[k]; b[k] = t;
		}
		if( c>k )
			for(i=0;i<n;i++) {
				t = A[i*Ainc+c]; A[i*Ainc+c] = A[i*Ainc+k]; A[i*Ainc+k] = t;
			}
		s = -1.0/A[k*(Ainc+1)];
		for(i=k+1;i<n;i++)
			if( A[i*Ainc+k]!=0.0 ) {
				t = s*A[i*Ainc+k];
				A[i*Ainc+k] = t;
				for(j=k+1;j<n;j++)
					A[i*Ainc+j] += t*A[k*Ainc+j];
				b[i] += t*b[k];
			}
	}
	for(j=n-1;j>0;j--) {
		b[j] = b[j]/A[j*(Ainc+1)];
		t = -b[j];
		for(i=0;i<j;i++)
			b[i] += t*A[i*Ainc+j];
	}
	b[0] = b[0]/A[0];
	for(j=n-2;j>=0;j--) {
		i = ip[n+j];
		if(i!=j) {
			t = b[i]; b[i] = b[j]; b[j] = t;
		}
	}
	for(j=0;j<n;j++) b[j] *= A[n*Ainc+j];
}
#ifdef MSVC
#pragma optimize( "", on)
#endif

#ifdef MSVC
#pragma optimize( "gty", on)
#endif
static void DecompCInc(M_INT n, double *A, M_INT Ainc, M_INT *ip)
{
	M_INT i,j,k,m;
	double t;

	ip[n-1]=1;
	for(k=0;k<n-1;k++) {
		m=k;
		for(i=k+1;i<n;i++)
			if( fabs(A[i*Ainc+k])>fabs(A[m*Ainc+k]) ) m=i;
		ip[k]=m;
		if( m!=k ) ip[n-1]=-ip[n-1];
		t=A[m*Ainc+k]; A[m*Ainc+k]=A[(Ainc+1)*k]; A[(Ainc+1)*k]=t;
		if( t==0.0 ) { ip[n-1]=0; return; }
		t=-1.0/t;
		for(i=k+1;i<n;i++) A[i*Ainc+k]=A[i*Ainc+k]*t;
		for(j=k+1;j<n;j++) {
			t=A[m*Ainc+j]; A[m*Ainc+j]=A[k*Ainc+j]; A[k*Ainc+j]=t;
			if( t!=0.0 )
				for(i=k+1;i<n;i++) A[i*Ainc+j]+=A[i*Ainc+k]*t;
		}
	}
	if(A[(n-1)*(Ainc+1)]==0.0) ip[n-1]=0;
}
#ifdef MSVC
#pragma optimize( "", on)
#endif

#ifdef MSVC
#pragma optimize( "gty", on)
#endif
static void MultiSolveCInc(M_INT n, double *A, M_INT Ainc, M_INT *ip, M_INT nb, double *b, M_INT binc)
{
	M_INT i,j,k,m;
	double t;

	if( n>1 ) {
		for(j=0;j<n-1;j++) {
			m=ip[j];
			for(k=0;k<nb;k++) {
				t=b[m*binc+k]; b[m*binc+k]=b[j*binc+k]; b[j*binc+k]=t;
				for(i=j+1;i<n;i++) b[i*binc+k]+=A[i*Ainc+j]*t;
			}
		}
		for(j=n-1;j>0;j--) {
			for(k=0;k<nb;k++) {
				b[j*binc+k]=b[j*binc+k]/A[(Ainc+1)*j];
				t=-b[j*binc+k];
				for(i=0;i<=j-1;i++) b[i*binc+k]+=A[i*Ainc+j]*t;
			}
		}
	}
	for(k=0;k<nb;k++)
		b[k]=b[k]/A[0];
}
#ifdef MSVC
#pragma optimize( "", on)
#endif

static void fp(int N, double T, double *Y, double *YP)
{
	double M[84], V[6], Z[107];
	int ti1, ti2;
	M_INT P[11];

	UNUSED(N);
	UNUSED(T);
	YP[6] = Y[7];
	YP[8] = Y[9];
	YP[10] = Y[11];
	YP[12] = Y[13];
	YP[14] = Y[15];
	Z[99] = sin(Y[6]);
	Z[100] = cos(Y[6]);
	Z[101] = cos(Y[8]);
	Z[102] = sin(Y[8]);
	Z[0] = Z[102];
	Z[1] = Z[100];
	Z[2] = Z[101];
	Z[3] = Z[99];
	Z[4] = Z[0]*Z[1]+Z[2]*Z[3];
	Z[5] = Z[1]*Z[2]-Z[0]*Z[3];
	Z[6] = -0.03145769966334020184;
	Z[7] = 0.01737446805143240149;
	Z[8] = 0.01869724304842369895;
	Z[9] = 0.31*Z[0];
	Z[6] = Z[4]*Z[7]+Z[5]*Z[8]+Z[6]-Z[9];
	Z[10] = -6.287826248000000487e-08;
	Z[11] = 0.31*Z[2];
	Z[10] = Z[4]*Z[8]+Z[10]+Z[11]-Z[5]*Z[7];
	Z[12] = 115197278836260600.*Z[1]-123967623903226700.*Z[3]-2055381283244332467.;
	Z[13] = -1.076133265955284545;
	Z[14] = Z[1]*Z[13]-Z[3];
	Z[15] = 115197278836260600.*Z[14];
	Z[13] = Z[3]*Z[13]+Z[1];
	Z[16] = 1.508235978050155759e-19;
	Z[7] = Z[7]*(Z[0]*Z[14]+Z[2]*Z[13])*Y[7]+Z[16]*(Z[0]*Z[15]+Z[2]*Z[12])*Y[9];
	Z[8] = Z[16]*(Z[0]*Z[12]-Z[2]*Z[15])*Y[9]+Z[8]*Y[7]*(0.9292529388656144078*(Z[0]*Z[13]-Z[2]*Z[14]));
	Z[12] = Z[6]*Z[6]+Z[10]*Z[10];
	if( Z[12]<=0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Z[13] = (1.0/(sqrt(Z[12])));
	Z[12] = Z[12]*Z[13];
	Z[13] = (Z[6]*Z[7]+Z[8]*Z[10])*Z[13];
	Z[14] = Z[12]-0.1191861621963549957;
	Z[15] = Z[14]*Z[14]+0.0008878947341260773834;
	Z[16] = (1.0/(sqrt(Z[15])));
	Z[14] = Z[16]*Z[14];
	Y[20] = Z[14]*Z[13];
	if( Y[20]<=0. )
		Y[19] = (2.+6.*Y[0]+0.8721841360538358158*Y[20])/(2.+6.*Y[0]-3.488736544215343263*Y[20]);
	else
		Y[19] = (1.6+4.8*Y[0]+15.69931444896904468*Y[20])/(1.6+4.8*Y[0]+8.721841360538358158*Y[20]);
	Z[15] = -1.+6.977473088430686526*Z[15]*Z[16];
	Y[21] = -798.520000000001*Z[14]*Y[0]*exp(-2.222222222222222222*Z[15]*Z[15])*Y[19];
	Z[14] = 0.04715016227153790061;
	Z[15] = 0.03143025891654109997;
	Z[16] = 0.004258009264589300018;
	Z[9] = Z[5]*Z[16]+Z[15]-Z[4]*Z[14]-Z[9];
	Z[4] = Z[4]*Z[16]+Z[5]*Z[14]+Z[11]+0.009977209043000000111;
	Z[5] = -751595164385510000.*Z[3]-8322629604869613600.*Z[1]-54719115549407157000.;
	Z[11] = 0.0903074148518814035;
	Z[15] = Z[1]*Z[11]-Z[3];
	Z[17] = 8322629604869613600.*Z[15];
	Z[11] = Z[3]*Z[11]+Z[1];
	Z[18] = 5.665296247708788693e-21;
	Z[14] = Z[18]*(Z[2]*Z[5]-Z[0]*Z[17])*Y[9]-Z[14]*Y[7]*(Z[0]*Z[15]+Z[2]*Z[11]);
	Z[5] = Z[16]*Y[7]*(11.07328785393934546*(Z[2]*Z[15]-Z[0]*Z[11]))+Z[18]*(Z[0]*Z[5]+Z[2]*Z[17])*Y[9];
	Z[11] = Z[4]*Z[4]+Z[9]*Z[9];
	if( Z[11]<=0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Z[15] = (1.0/(sqrt(Z[11])));
	Z[11] = Z[11]*Z[15];
	Z[15] = (Z[4]*Z[5]+Z[9]*Z[14])*Z[15];
	Z[16] = Z[11]-0.1876654718923540032;
	if( Z[16]*Z[16]<=0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Z[17] = Z[16]/sqrt(Z[16]*Z[16]);
	Y[24] = Z[17]*Z[15];
	if( Y[24]<=0. )
		Y[23] = (2.+6.*Y[1]+0.9687894451051341538*Y[24])/(2.+6.*Y[1]-3.875157780420536615*Y[24]);
	else
		Y[23] = (1.6+4.8*Y[1]+17.43821001189241477*Y[24])/(1.6+4.8*Y[1]+9.687894451051341538*Y[24]);
	Z[16] = -1.+7.750315560841073231*fabs(Z[16]);
	Y[25] = -971.6839440783530021*Z[17]*Y[1]*exp(-2.222222222222222222*Z[16]*Z[16])*Y[23];
	Z[16] = 0.001088386836323859039*Z[3]+0.05819953671129420221*Z[1];
	Z[17] = -0.001088386836323859039*Z[1]+0.05819953671129420221*Z[3];
	Z[18] = 0.01939984557043140074*Z[3]-0.0001612100150651070088-0.0003627956121079530131*Z[1];
	Z[19] = -0.01939984557043140074*Z[1]+0.1009578529976279903-0.0003627956121079530131*Z[3];
	Z[20] = Z[18]*Z[18]+Z[19]*Z[19];
	if( Z[20]<=0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Z[21] = (1.0/(sqrt(Z[20])));
	Z[20] = Z[20]*Z[21];
	Z[21] = 0.3333333333333333333*Y[7]*(Z[16]*Z[18]+Z[17]*Z[19])*Z[21];
	Z[22] = Z[20]-0.007207271244649430134;
	Z[23] = Z[22]*Z[22]+0.000215371568910646809;
	Z[24] = (1.0/(sqrt(Z[23])));
	Z[22] = Z[24]*Z[22];
	Y[28] = Z[22]*Z[21];
	if( Y[28]<=0. )
		Y[27] = (2.+6.*Y[2]+1.149764148384612096*Y[28])/(2.+6.*Y[2]-4.599056593538448384*Y[28]);
	else
		Y[27] = (1.6+4.8*Y[2]+20.69575467092301773*Y[28])/(1.6+4.8*Y[2]+11.49764148384612096*Y[28]);
	Z[23] = -1.+9.198113187076896769*Z[23]*Z[24];
	Y[29] = -1577.017267470980048*Z[22]*Y[2]*exp(-2.222222222222222222*Z[23]*Z[23])*Y[27];
	Z[22] = -0.02486856581214240076;
	Z[23] = Z[1]*Z[22]-0.0008907096092813949785*Z[3];
	Z[22] = Z[3]*Z[22]+0.0008907096092813949785*Z[1];
	Z[24] = 0.001781419218562789957*Z[1]-0.04973713162428480153*Z[3]-0.001196151814771630075;
	Z[1] = 0.001781419218562789957*Z[3]+0.04973713162428480153*Z[1]+0.1001922804;
	Z[3] = Z[1]*Z[1]+Z[24]*Z[24];
	if( Z[3]<=0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Z[25] = (1.0/(sqrt(Z[3])));
	Z[3] = Z[3]*Z[25];
	Z[25] = 2.*Y[7]*(Z[1]*Z[22]+Z[23]*Z[24])*Z[25];
	Z[26] = Z[3]-0.01811680735798800181;
	Z[27] = Z[26]*Z[26]+8.356635327544370825e-06;
	Z[28] = (1.0/(sqrt(Z[27])));
	Z[26] = Z[28]*Z[26];
	Y[32] = Z[26]*Z[25];
	if( Y[32]<=0. )
		Y[31] = (2.+6.*Y[3]+1.067241872576417184*Y[32])/(2.+6.*Y[3]-4.268967490305668734*Y[32]);
	else
		Y[31] = (1.6+4.8*Y[3]+19.2103537063755093*Y[32])/(1.6+4.8*Y[3]+10.67241872576417184*Y[32]);
	Z[27] = -1.+8.537934980611337468*Z[27]*Z[28];
	Y[33] = -1452.279722084529891*Z[26]*Y[3]*exp(-2.222222222222222222*Z[27]*Z[27])*Y[31];
	Z[26] = -0.01488499887723043396;
	Z[27] = Z[2]*Z[26]-7.399252748545999873e-10*Z[0];
	Z[26] = Z[0]*Z[26]+7.399252748545999873e-10*Z[2];
	Z[28] = -0.04465497329256169882-0.04465499663169130187*Z[0]+2.219775824563799962e-09*Z[2];
	Z[29] = 0.04465499663169130187*Z[2]+2.219775824563799962e-09*Z[0]-2.219790209527749963e-09;
	Z[30] = Z[28]*Z[28]+Z[29]*Z[29];
	if( Z[30]<=0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Z[31] = (1.0/(sqrt(Z[30])));
	Z[30] = Z[30]*Z[31];
	Z[31] = 3.*Y[9]*(Z[26]*Z[29]+Z[27]*Z[28])*Z[31];
	Z[32] = Z[30]*Z[30]+0.005336516956112195437;
	Z[33] = (1.0/(sqrt(Z[32])));
	Z[34] = Z[33]*Z[30];
	Y[36] = Z[34]*Z[31];
	if( Y[36]<=0. )
		Y[35] = (2.+6.*Y[4]+0.569861042669439647*Y[36])/(2.+6.*Y[4]-2.279444170677758588*Y[36]);
	else
		Y[35] = (1.6+4.8*Y[4]+10.25749876804991365*Y[36])/(1.6+4.8*Y[4]+5.69861042669439647*Y[36]);
	Z[32] = -1.+4.558888341355517176*Z[32]*Z[33];
	Y[37] = -1672.43249129511998*Z[34]*Y[4]*exp(-2.222222222222222222*Z[32]*Z[32])*Y[35];
	Z[32] = -0.01075173575611254275;
	Z[33] = Z[2]*Z[32]+0.003924854783396900058*Z[0];
	Z[32] = Z[0]*Z[32]-0.003924854783396900058*Z[2];
	Z[34] = -0.0274739834837783004*Z[2]+0.03211993553327720254-0.07526215029278779926*Z[0];
	Z[0] = -0.0274739834837783004*Z[0]+0.07179454623553609659+0.07526215029278779926*Z[2];
	Z[2] = Z[0]*Z[0]+Z[34]*Z[34];
	if( Z[2]<=0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Z[35] = (1.0/(sqrt(Z[2])));
	Z[2] = Z[2]*Z[35];
	Z[35] = 7.*Y[9]*(Z[0]*Z[32]+Z[33]*Z[34])*Z[35];
	Z[36] = Z[2]-0.02916969277103229945;
	Z[37] = Z[36]*Z[36]+0.001959012092791772675;
	Z[38] = (1.0/(sqrt(Z[37])));
	Z[36] = Z[38]*Z[36];
	Y[40] = Z[36]*Z[35];
	if( Y[40]<=0. )
		Y[39] = (2.+6.*Y[5]+1.041121831235231223*Y[40])/(2.+6.*Y[5]-4.164487324940924892*Y[40]);
	else
		Y[39] = (1.6+4.8*Y[5]+18.74019296223416201*Y[40])/(1.6+4.8*Y[5]+10.41121831235231223*Y[40]);
	Z[37] = -1.+8.328974649881849784*Z[37]*Z[38];
	Y[41] = -2524.662523332499958*Z[36]*Y[5]*exp(-2.222222222222222222*Z[37]*Z[37])*Y[39];
	Z[1] = Y[72];
	if( Y[0]<Z[1] )
		Y[22] = 0.0075+0.0225*Y[0];
	else {
		Z[0] = 0.5+1.5*Y[0];
		Z[0] = 1.0/Z[0];
		Y[22] = 0.04*Z[0];
	}
	Z[103] = cos(Y[10]);
	Z[104] = sin(Y[12]);
	Z[105] = cos(Y[12]);
	Z[106] = sin(Y[10]);
	for(ti1=0;ti1<=5;ti1++)
		for(ti2=0;ti2<=5;ti2++)
			M[ti1*12+ti2] = 0.;
	for(ti1=0;ti1<=5;ti1++)
		V[ti1] = 0.;
	Z[0] = Z[104];
	Z[1] = Z[105];
	Z[2] = Z[0]*Z[0]+Z[1]*Z[1];
	Z[3] = 0.005;
	M[1] = Z[3]+0.01125*Z[2];
	Z[4] = -0.15;
	M[5] = Z[4]-0.15*Z[2];
	Z[2] = Y[79];
	V[0] = Y[78]-Z[2];
	Z[4] = Z[102];
	Z[5] = Z[100];
	Z[6] = Z[103];
	Z[7] = Z[99];
	Z[8] = Z[106];
	Z[9] = Z[7]*Z[8];
	Z[10] = Z[5]*Z[6];
	Z[11] = Z[10]-Z[9];
	Z[12] = Z[101];
	Z[6] = Z[6]*Z[7];
	Z[8] = Z[5]*Z[8];
	Z[13] = Z[8]+Z[6];
	Z[14] = Z[12]*Z[13];
	Z[15] = Z[4]*Z[11]+Z[14];
	Z[16] = Z[4]*Z[13];
	Z[17] = Z[11]*Z[12]-Z[16];
	M[12] = Z[3]+0.01125*(Z[15]*Z[15]+Z[17]*Z[17]);
	Z[18] = Z[12]*Z[7];
	Z[19] = Z[4]*Z[5];
	Z[20] = Z[19]+Z[18];
	Z[21] = 0.075*Z[15];
	Z[22] = 0.17*Z[20];
	Z[23] = Z[22]-Z[21];
	Z[24] = Z[12]*Z[5];
	Z[25] = Z[4]*Z[7];
	Z[26] = Z[24]-Z[25];
	Z[27] = 0.075*Z[17];
	Z[28] = 0.17*Z[26];
	Z[29] = Z[27]-Z[28];
	Z[30] = Z[15]*Z[23];
	Z[31] = Z[17]*Z[29];
	M[14] = Z[3]+0.15*(Z[31]-Z[30]);
	Z[32] = 0.155*Z[4];
	Z[22] = Z[32]+Z[22]-Z[21];
	Z[33] = 0.155*Z[12];
	Z[28] = Z[27]-Z[33]-Z[28];
	Z[34] = Z[15]*Z[22];
	Z[35] = Z[17]*Z[28];
	M[15] = Z[3]+0.15*(Z[35]-Z[34]);
	Z[36] = Z[1]*Z[15];
	Z[37] = Z[36]-Z[0]*Z[17];
	Z[38] = 0.3*Z[37];
	M[16] = Z[38];
	Z[39] = Z[0]*Z[15];
	Z[40] = Z[1]*Z[17]+Z[39];
	Z[41] = 0.3*Z[40];
	M[17] = Z[41];
	Z[42] = Y[9]+Y[7];
	Z[43] = Y[9]+Y[7]+Y[11];
	Z[44] = Y[9]*Y[9];
	Z[45] = Z[42]*Z[42];
	Z[33] = Z[33]*Z[44];
	Z[46] = 0.17*Z[45];
	Z[47] = Z[46]*Z[26];
	Z[43] = 0.075*Z[43]*Z[43];
	Z[48] = Z[43]*Z[17];
	Z[32] = Z[32]*Z[44];
	Z[46] = Z[46]*Z[20];
	Z[43] = Z[43]*Z[15];
	Z[49] = Z[15]*(Z[47]+Z[33]-Z[48]);
	Z[50] = Z[17]*(Z[46]+Z[32]-Z[43]);
	V[1] = Z[2]+0.15*(Z[49]-Z[50]);
	Z[51] = -0.01425;
	Z[51] = Z[51]*(Z[15]*Z[20]+Z[17]*Z[26]);
	Z[52] = 0.01125*(Z[15]*(Z[15]-Z[20])+Z[17]*(Z[17]-Z[26]));
	M[24] = Z[3]+Z[52]+Z[51];
	Z[53] = 0.4588*Z[20];
	Z[54] = Z[53]-Z[21];
	Z[55] = 0.4588*Z[26];
	Z[56] = Z[27]-Z[55];
	Z[57] = 0.0238;
	Z[58] = 0.19;
	Z[23] = 0.15*(Z[26]*Z[29]+Z[30]-Z[20]*Z[23]-Z[31]);
	Z[29] = Z[58]*(Z[20]*Z[54]-Z[26]*Z[56]);
	M[26] = Z[57]+Z[29]-Z[23];
	Z[30] = 0.6262*Z[4];
	Z[31] = Z[30]+Z[53]-Z[21];
	Z[59] = 0.6262*Z[12];
	Z[60] = Z[27]-Z[59]-Z[55];
	Z[22] = 0.15*(Z[28]*Z[26]+Z[34]-Z[20]*Z[22]-Z[35]);
	Z[28] = Z[58]*(Z[20]*Z[31]-Z[26]*Z[60]);
	M[27] = Z[57]+Z[28]-Z[22];
	Z[34] = Z[1]*Z[20];
	Z[35] = Z[34]-Z[0]*Z[26];
	Z[61] = -0.34*Z[35];
	M[28] = Z[38]+Z[61];
	Z[62] = Z[0]*Z[20];
	Z[63] = Z[1]*Z[26]+Z[62];
	Z[64] = -0.34*Z[63];
	M[29] = Z[41]+Z[64];
	Z[65] = -0.0003627956121079530131*Z[7];
	Z[66] = 0.01939984557043140074*Z[5];
	Z[67] = Z[65]-Z[66]+0.1009578529976279903;
	Z[68] = -0.0003627956121079530131*Z[5];
	Z[69] = 0.01939984557043140074*Z[7];
	Z[70] = Z[69]+Z[68]-0.0001612100150651070088;
	Z[71] = Z[67]*Z[67]+Z[70]*Z[70];
	Z[72] = 0.001781419218562789957*Z[7];
	Z[73] = 0.04973713162428480153*Z[5];
	Z[74] = Z[72]+Z[73]+0.1001922804;
	Z[5] = 0.001781419218562789957*Z[5];
	Z[7] = 0.04973713162428480153*Z[7];
	Z[75] = Z[5]-Z[7]-0.001196151814771630075;
	Z[76] = Z[74]*Z[74]+Z[75]*Z[75];
	Z[77] = 0.31;
	Z[78] = 0.01869724304842369895*Z[20];
	Z[79] = Z[77]*Z[12];
	Z[80] = 0.01737446805143240149*Z[26];
	Z[81] = Z[79]+Z[78]-Z[80]-6.287826248000000487e-08;
	Z[82] = Z[77]*Z[4];
	Z[83] = 0.01737446805143240149*Z[20];
	Z[84] = 0.01869724304842369895*Z[26];
	Z[85] = Z[84]+Z[83]-Z[82]-0.03145769966334020184;
	Z[86] = Z[81]*Z[81]+Z[85]*Z[85];
	Z[87] = 0.04715016227153790061*Z[26];
	Z[88] = 0.004258009264589300018*Z[20];
	Z[79] = Z[79]+Z[88]+Z[87]+0.009977209043000000111;
	Z[89] = 0.04715016227153790061*Z[20];
	Z[90] = 0.004258009264589300018*Z[26];
	Z[82] = Z[90]-Z[82]-Z[89]+0.03143025891654109997;
	Z[91] = Z[79]*Z[79]+Z[82]*Z[82];
	if( Z[86]>1e-15 )
		Z[92] = Z[86];
	else
		Z[92] = 1e-15;
	if( Z[92]<=0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Z[92] = (1.0/(sqrt(Z[92])));
	if( Z[91]>1e-15 )
		Z[93] = Z[91];
	else
		Z[93] = 1e-15;
	if( Z[93]<=0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Z[93] = (1.0/(sqrt(Z[93])));
	if( Z[71]>1e-15 )
		Z[94] = Z[71];
	else
		Z[94] = 1e-15;
	if( Z[94]<=0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Z[94] = (1.0/(sqrt(Z[94])));
	if( Z[76]>1e-15 )
		Z[95] = Z[76];
	else
		Z[95] = 1e-15;
	Z[96] = Y[71];
	Z[97] = Y[70];
	Z[59] = Z[59]*Z[44];
	Z[45] = 0.4588*Z[45];
	Z[98] = Z[45]*Z[26];
	Z[30] = Z[30]*Z[44];
	Z[45] = Z[45]*Z[20];
	Z[78] = (Z[85]*(Z[78]-Z[80])-Z[81]*(Z[84]+Z[83]))*Z[92]*Y[21];
	Z[65] = (Z[70]*(Z[65]-Z[66])-Z[67]*(Z[69]+Z[68]))*Z[94]*Y[29];
	if( Z[95]<=0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Z[66] = Y[33]/sqrt(Z[95]);
	Z[5] = Z[66]*(Z[75]*(Z[72]+Z[73])-Z[74]*(Z[5]-Z[7]));
	Z[7] = (Z[82]*(Z[88]+Z[87])-Z[79]*(Z[90]-Z[89]))*Z[93]*Y[25];
	Z[32] = 0.15*(Z[20]*(Z[48]-Z[47]-Z[33]-Z[96])+Z[49]-Z[26]*(Z[43]-Z[46]-Z[32]-Z[97])-Z[50]);
	Z[33] = Z[58]*(Z[20]*(Z[98]+Z[59]+Z[96]-Z[48])-Z[26]*(Z[45]+Z[30]+Z[97]-Z[43]));
	V[2] = Z[2]+Z[32]-Y[7]*Y[80]-Z[5]-Z[7]-Z[33]-Z[65]-Z[78];
	Z[46] = -0.02325;
	M[36] = Z[46]*(Z[4]*Z[15]+Z[12]*Z[17])+Z[3]+Z[51]+Z[52];
	Z[3] = 0.165;
	M[38] = Z[29]+Z[57]-Z[3]*(Z[12]*Z[56]-Z[4]*Z[54])-Z[23]+0.145*(Z[4]*Z[54]-Z[12]*Z[56]);
	Z[23] = 0.94465*Z[12];
	Z[29] = 0.94465*Z[4];
	M[39] = Z[28]-Z[3]*(Z[12]*(Z[27]-Z[23]-Z[55])-Z[4]*(Z[29]+Z[53]-Z[21]))-Z[22]+0.0379+0.145*(Z[4]*Z[31]-Z[12]*Z[60]);
	Z[21] = Z[4]*Z[1];
	Z[22] = Z[0]*Z[12];
	Z[27] = Z[22]-Z[21];
	M[40] = Z[38]+Z[61]+0.31*Z[27];
	Z[28] = Z[12]*Z[1];
	Z[31] = Z[4]*Z[0];
	Z[38] = Z[31]+Z[28];
	M[41] = Z[41]+Z[64]-0.31*Z[38];
	Z[41] = 0.07526215029278779926*Z[12];
	Z[46] = -0.0274739834837783004*Z[4];
	Z[47] = Z[46]+Z[41]+0.07179454623553609659;
	Z[49] = 0.07526215029278779926*Z[4];
	Z[50] = -0.0274739834837783004*Z[12];
	Z[51] = Z[50]-Z[49]+0.03211993553327720254;
	Z[52] = Z[47]*Z[47]+Z[51]*Z[51];
	Z[53] = 2.219775824563799962e-09*Z[4];
	Z[54] = 0.04465499663169130187*Z[12];
	Z[55] = Z[53]+Z[54]-2.219790209527749963e-09;
	Z[56] = 2.219775824563799962e-09*Z[12];
	Z[57] = 0.04465499663169130187*Z[4];
	Z[58] = Z[56]-Z[57]-0.04465497329256169882;
	Z[60] = Z[55]*Z[55]+Z[58]*Z[58];
	if( Z[52]>1e-15 )
		Z[61] = Z[52];
	else
		Z[61] = 1e-15;
	if( Z[60]>1e-15 )
		Z[64] = Z[60];
	else
		Z[64] = 1e-15;
	Z[68] = Z[93]*Y[25];
	Z[69] = Z[92]*Y[21];
	Z[72] = Z[68]*Z[79]+Z[69]*Z[81]+Z[96];
	Z[68] = Z[68]*Z[82]+Z[69]*Z[85]-Z[97];
	if( Z[61]<=0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	if( Z[64]<=0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	V[3] = Z[3]*(Z[12]*(Z[29]*Z[44]+Z[45]-Z[43]-Z[68])-Z[4]*(Z[23]*Z[44]+Z[72]+Z[98]-Z[48]))+Z[32]+Z[2]+Y[29]*Z[94]*(-0.1009578529976279903*Z[70]-0.0001612100150651070088*Z[67])+Z[66]*(-0.001196151814771630075*Z[74]-0.1001922804*Z[75])-Z[33]-Y[81]*Y[9]-Z[5]-Z[7]-Z[65]-Z[78]-((Z[51]*(Z[46]+Z[41])-Z[47]*(Z[50]-Z[49]))*Y[41])/sqrt(Z[61])-(Y[37]*(Z[58]*(Z[53]+Z[54])-Z[55]*(Z[56]-Z[57])))/sqrt(Z[64])+0.145*(Z[4]*(Z[48]-Z[98]-Z[59]-Z[72])-Z[12]*(Z[43]+Z[68]-Z[45]-Z[30]));
	Z[2] = Z[4]*Z[11]+Z[14];
	Z[3] = Z[16]-Z[11]*Z[12];
	Z[5] = 0.3;
	Z[7] = Z[5]*(Z[0]*Z[3]+Z[1]*Z[2]);
	M[48] = -Z[7];
	Z[14] = 0.34;
	Z[16] = Z[77]*Z[27];
	Z[23] = 0.8*Z[1];
	M[49] = Z[5]*(Z[36]-Z[0]*Z[17])+Z[16]+Z[23]-Z[14]*(Z[34]-Z[0]*Z[26]);
	Z[29] = Z[14]*Z[35];
	M[50] = Z[29]-Z[7];
	M[51] = Z[29]-Z[5]*Z[37]-Z[16];
	Z[7] = Y[7]+Y[11];
	Z[16] = Z[6]*Z[7]+Z[7]*Z[8];
	Z[7] = Z[7]*Z[10]-Z[7]*Z[9];
	Z[29] = Z[11]*Y[9]+Z[7];
	Z[30] = Z[13]*Y[9]+Z[16];
	Z[32] = Z[4]*Z[29]+Z[12]*Z[30];
	Z[29] = Z[12]*Z[29]-Z[4]*Z[30];
	Z[30] = Z[18]*Z[42]+Z[19]*Z[42];
	Z[33] = Z[25]*Z[42]-Z[24]*Z[42];
	Z[34] = Y[7]*Y[7];
	Z[35] = Z[34]+Z[44];
	Z[36] = Y[9]*Y[7];
	Z[37] = 2.;
	Z[34] = Y[11]*Y[11]+Z[34];
	Z[41] = Y[7]*Y[11];
	Z[6] = -(Z[13]*Z[37]*Z[41]+Z[6]*Z[34]+Z[8]*Z[34]+Z[13]*Z[44]);
	Z[8] = Z[11]*Z[37]*Z[41]+Z[10]*Z[34]+Z[11]*Z[44]-Z[9]*Z[34];
	Z[9] = Y[13]*Y[13];
	Z[10] = Z[15]*Z[9]+Z[37]*Y[9]*(Z[4]*Z[7]+Z[12]*Z[16])+Z[4]*Z[8]-Z[6]*Z[12];
	Z[4] = Z[17]*Z[9]+Z[4]*Z[6]+Z[8]*Z[12]-Z[37]*Y[9]*(Z[4]*Z[16]-Z[12]*Z[7]);
	Z[6] = Z[20]*Z[36]*Z[37]+Z[9]*Z[20]+Z[18]*Z[35]+Z[19]*Z[35];
	Z[7] = Z[26]*Z[36]*Z[37]+Z[9]*Z[26]+Z[24]*Z[35]-Z[25]*Z[35];
	Z[8] = Z[9]+Z[44];
	Z[11] = Y[13]*Y[9];
	Z[12] = 0.62;
	Z[13] = 0.68;
	Z[15] = 0.6;
	Z[16] = 0.8*Z[0];
	V[4] = Z[5]*(Z[0]*Z[10]+Z[4]*Z[1])+Z[13]*Y[13]*(Z[0]*Z[30]-Z[1]*Z[33])+Z[12]*Z[11]*Z[38]+Z[16]*Z[9]-Z[14]*(Z[0]*Z[6]+Z[1]*Z[7])-Z[77]*(Z[8]*Z[28]+Z[8]*Z[31])-Z[15]*Y[13]*(Z[0]*Z[32]+Z[1]*Z[29]);
	Z[2] = Z[5]*(Z[0]*Z[2]-Z[1]*Z[3]);
	M[60] = -Z[2];
	Z[3] = Z[77]*Z[38];
	M[61] = Z[5]*(Z[1]*Z[17]+Z[39])+Z[16]-Z[14]*(Z[1]*Z[26]+Z[62])-Z[3];
	Z[16] = Z[14]*Z[63];
	M[62] = Z[16]-Z[2];
	M[63] = Z[3]+Z[16]-Z[5]*Z[40];
	V[5] = Z[5]*(Z[4]*Z[0]-Z[1]*Z[10])+Z[12]*Z[11]*Z[27]+Z[15]*Y[13]*(Z[1]*Z[32]-Z[0]*Z[29])-Z[13]*Y[13]*(Z[0]*Z[33]+Z[1]*Z[30])-Z[14]*(Z[0]*Z[7]-Z[1]*Z[6])-Z[77]*(Z[8]*Z[22]-Z[8]*Z[21])-Z[23]*Z[9];
	LSQDecompSolve(6,M,12,P,V);
	if( P[5]==0 ) {
		YP[0] = (*dsn_undef);
		return;
	}
	YP[11] = V[0];
	YP[13] = V[1];
	YP[7] = V[2];
	YP[9] = V[3];
	Y[16] = V[4];
	Y[17] = V[5];
	Z[1] = Y[73];
	if( Y[1]<Z[1] )
		Y[26] = 0.0075+0.0225*Y[1];
	else {
		Z[0] = 0.5+1.5*Y[1];
		Z[0] = 1.0/Z[0];
		Y[26] = 0.04*Z[0];
	}
	YP[0] = (Y[72]-Y[0])/Y[22];
	Z[1] = Y[74];
	if( Y[2]<Z[1] )
		Y[30] = 0.0075+0.0225*Y[2];
	else {
		Z[0] = 0.5+1.5*Y[2];
		Z[0] = 1.0/Z[0];
		Y[30] = 0.04*Z[0];
	}
	YP[1] = (Y[73]-Y[1])/Y[26];
	Z[1] = Y[75];
	if( Y[3]<Z[1] )
		Y[34] = 0.0075+0.0225*Y[3];
	else {
		Z[0] = 0.5+1.5*Y[3];
		Z[0] = 1.0/Z[0];
		Y[34] = 0.04*Z[0];
	}
	YP[2] = (Y[74]-Y[2])/Y[30];
	Z[1] = Y[77];
	if( Y[5]<Z[1] )
		Y[42] = 0.0075+0.0225*Y[5];
	else {
		Z[0] = 0.5+1.5*Y[5];
		Z[0] = 1.0/Z[0];
		Y[42] = 0.04*Z[0];
	}
	YP[3] = (Y[75]-Y[3])/Y[34];
	Z[1] = Y[76];
	if( Y[4]<Z[1] )
		Y[38] = 0.0075+0.0225*Y[4];
	else {
		Z[0] = 0.5+1.5*Y[4];
		Z[0] = 1.0/Z[0];
		Y[38] = 0.04*Z[0];
	}
	YP[5] = (Y[77]-Y[5])/Y[42];
	Z[0] = Z[102];
	Z[1] = Z[100];
	Z[2] = Z[103];
	Z[3] = Z[99];
	Z[4] = Z[106];
	Z[5] = Z[1]*Z[2]-Z[3]*Z[4];
	Z[6] = Z[101];
	Z[2] = Z[4]*Z[1]+Z[2]*Z[3];
	Z[4] = Z[0]*Z[5]+Z[2]*Z[6];
	Z[7] = Z[105];
	Z[8] = Z[104];
	Z[9] = YP[9]+YP[7];
	Z[10] = Z[0]*Z[1]+Z[3]*Z[6];
	Z[11] = Y[9]+Y[7];
	Z[1] = Z[1]*Z[6]-Z[0]*Z[3];
	Z[3] = YP[9]+YP[7]+YP[11];
	Z[12] = Y[9]+Y[7]+Y[11];
	Z[2] = Z[5]*Z[6]-Z[0]*Z[2];
	Z[5] = Z[7]*Y[16]+Z[8]*Y[17];
	Z[13] = Y[9]*Y[9];
	Z[11] = Z[11]*Z[11];
	Z[12] = Z[12]*Z[12];
	Z[14] = 0.155;
	Z[15] = 0.17;
	Z[16] = -0.075;
	Z[7] = Z[8]*Y[16]-Z[7]*Y[17];
	Z[8] = -0.15;
	Y[18] = Z[8]*(Z[2]*(Z[16]*(Z[4]*Z[12]-Z[2]*Z[3])-Z[14]*(Z[6]*YP[9]-Z[0]*Z[13])-Z[15]*(Z[1]*Z[9]-Z[10]*Z[11])-2.*Z[7])+Z[4]*(-(Z[14]*(Z[0]*YP[9]+Z[6]*Z[13])+Z[15]*(Z[1]*Z[11]+Z[9]*Z[10])+Z[16]*(Z[2]*Z[12]+Z[3]*Z[4]))+2.*Z[5]))+Y[79]-0.005*Z[3];
	YP[4] = (Y[76]-Y[4])/Y[38];
	YP[15] = YP[9]+YP[7]+YP[11]-YP[13];
	Y[43] = YP[7];
	Y[44] = YP[9];
	Y[45] = YP[11];
}

static void otp(double T, double *Y, double *YP)
{
	double Z[9];

	UNUSED(T);
	UNUSED(YP);
	Y[46] = -Y[21];
	Y[47] = -Y[25];
	Y[48] = -Y[29];
	Y[49] = -Y[33];
	Y[50] = -Y[37];
	Y[51] = -Y[41];
	Z[0] = cos(Y[8]);
	Z[1] = sin(Y[6]);
	Z[2] = sin(Y[8]);
	Z[3] = cos(Y[6]);
	Z[4] = Z[0]*Z[1]+Z[2]*Z[3];
	Z[5] = 0.31;
	Z[6] = 0.34*Z[4];
	Z[7] = -(Z[2]*Z[5]+Z[6]);
	Z[1] = Z[0]*Z[3]-Z[1]*Z[2];
	Z[2] = 0.34*Z[1];
	Z[0] = Z[0]*Z[5]+Z[2];
	Z[3] = Y[7]*Y[7];
	Z[5] = Y[9]*Y[9];
	Z[8] = Y[44]*Z[0]+Z[5]*Z[7]-0.68*Z[4]*Y[9]*Y[7]+0.34*(Y[43]*Z[1]-Z[3]*Z[4]);
	Y[52] = Z[8];
	Y[53] = 0.;
	Z[1] = Y[44]*Z[7]-Z[0]*Z[5]-0.68*Z[1]*Y[9]*Y[7]-0.34*(Y[43]*Z[4]+Z[1]*Z[3]);
	Y[54] = Z[1];
	Y[55] = Z[8];
	Y[56] = 0.;
	Y[57] = Z[1];
	Z[1] = -Z[7];
	Y[58] = Z[1];
	Y[59] = 0.;
	Y[60] = Z[0];
	Z[2] = Z[2]*Y[7]+Z[0]*Y[9];
	Y[61] = Z[2];
	Y[62] = 0.;
	Z[3] = Z[7]*Y[9]-Z[6]*Y[7];
	Y[63] = Z[3];
	Y[64] = Z[2];
	Y[65] = 0.;
	Y[66] = Z[3];
	Y[67] = Z[1];
	Y[68] = 0.;
	Y[69] = Z[0];
}

static void Rblkp(double T, double *Y, double *R, int prb, int code)
{
	double Z[17];

	UNUSED(T);
	if( prb==0 )
		R[0] = 2.;
	else if( prb==1 ) {
		if( code==1 ) {
			R[0] = 3.;
			R[1] = 5.;
		}
		else if( code==2 ) {
			R[0] = 7.;
			R[1] = 9.;
			R[2] = 11.;
			R[3] = 13.;
			R[4] = 15.;
		}
		else if( code==3 ) {
			Z[0] = sin(Y[10]);
			Z[1] = cos(Y[6]);
			Z[2] = cos(Y[8]);
			Z[3] = cos(Y[12]);
			Z[4] = sin(Y[8]);
			Z[5] = sin(Y[12]);
			Z[6] = Z[2]*Z[3]+Z[4]*Z[5];
			Z[7] = sin(Y[6]);
			Z[8] = Z[2]*Z[5]-Z[3]*Z[4];
			Z[9] = cos(Y[10]);
			R[0] = Z[0]*(Z[1]*Z[6]+Z[7]*Z[8])+Z[9]*(Z[6]*Z[7]-Z[1]*Z[8])+sin(Y[14]);
			Z[10] = Z[1]*Z[2]-Z[4]*Z[7];
			Z[11] = Z[4]*Z[1]+Z[2]*Z[7];
			Z[12] = Z[1]*Z[9]-Z[0]*Z[7];
			Z[0] = Z[0]*Z[1]+Z[7]*Z[9];
			Z[1] = Z[2]*Z[12]-Z[0]*Z[4];
			Z[0] = Z[0]*Z[2]+Z[4]*Z[12];
			Z[2] = -0.31;
			Z[4] = -0.34;
			Z[7] = 0.3;
			R[1] = Z[8]*Z[2]+Z[4]*(Z[5]*Z[10]-Z[3]*Z[11])+Z[7]*(Z[1]*Z[5]-Z[0]*Z[3])-0.8*Z[3];
			R[2] = Z[2]*Z[6]+Z[4]*(Z[3]*Z[10]+Z[5]*Z[11])-Z[7]*(1.-Z[0]*Z[5]-Z[1]*Z[3])+0.8*Z[5];
		}
	}
	else if( prb==2 ) {
		if( code==1 ) {
			R[0] = 3.;
			R[1] = 5.;
		}
		else if( code==2 ) {
			R[0] = 8.;
			R[1] = 10.;
			R[2] = 12.;
			R[3] = 14.;
			R[4] = 16.;
		}
		else if( code==3 ) {
			R[0] = Y[15]+Y[13]-Y[9]-Y[7]-Y[11];
			Z[0] = cos(Y[12]);
			Z[1] = sin(Y[8]);
			Z[2] = cos(Y[6]);
			Z[3] = cos(Y[8]);
			Z[4] = sin(Y[6]);
			Z[5] = Y[9]+Y[7];
			Z[6] = Z[3]*Z[4];
			Z[7] = Z[1]*Z[2];
			Z[8] = sin(Y[12]);
			Z[9] = Z[2]*Z[3];
			Z[10] = Z[4]*Z[1];
			Z[11] = cos(Y[10]);
			Z[12] = sin(Y[10]);
			Z[13] = Z[4]*Z[12];
			Z[14] = Z[2]*Z[11];
			Z[15] = Z[14]-Z[13];
			Z[16] = Y[7]+Y[11];
			Z[4] = Z[4]*Z[11];
			Z[2] = Z[2]*Z[12];
			Z[11] = Z[2]+Z[4];
			Z[12] = Z[15]*Y[9]+Z[14]*Z[16]-Z[13]*Z[16];
			Z[2] = Z[11]*Y[9]+Z[2]*Z[16]+Z[4]*Z[16];
			Z[4] = Z[12]*Z[1]+Z[2]*Z[3]-Y[13]*(Z[1]*Z[15]+Z[3]*Z[11]);
			Z[2] = Y[13]*(Z[3]*Z[15]-Z[1]*Z[11])+Z[1]*Z[2]-Z[3]*Z[12];
			Z[9] = Y[13]*(Z[9]-Z[10])+Z[5]*Z[10]-Z[9]*Z[5];
			Z[5] = Z[5]*Z[6]+Z[5]*Z[7]-Y[13]*(Z[7]+Z[6]);
			Z[6] = Y[9]-Y[13];
			Z[7] = Z[6]*Z[8];
			Z[10] = 0.31;
			Z[11] = -0.3;
			Z[12] = 0.34;
			Z[13] = 0.8*Y[13];
			R[1] = Z[11]*(Z[0]*Z[4]+Z[8]*Z[2])+Z[12]*(Z[0]*Z[5]+Z[8]*Z[9])+Z[10]*(Z[0]*Z[1]*Z[6]-Z[3]*Z[7])+Z[0]*Z[13];
			R[2] = Z[11]*(Z[4]*Z[8]-Z[0]*Z[2])+Z[12]*(Z[5]*Z[8]-Z[0]*Z[9])+Z[13]*Z[8]-Z[10]*(-(Z[0]*Z[3]*Z[6]+Z[1]*Z[7]));
		}
	}
}

static void Jblkp(double T, double *Y, double *J, int prb)
{
	double U[48], Z[8];
	int ti1, ti2;

	UNUSED(T);
	if( prb==1 ) {
		for(ti1=0;ti1<=2;ti1++)
			for(ti2=0;ti2<=4;ti2++)
				J[ti1*16+ti2] = 0.;
		Z[0] = sin(Y[10]);
		U[0] = Z[0];
		Z[1] = cos(Y[10]);
		U[1] = Z[1];
		Z[2] = cos(Y[6]);
		U[2] = Z[2];
		Z[3] = sin(Y[6]);
		U[3] = -Z[3];
		Z[4] = cos(Y[8]);
		U[4] = Z[4];
		Z[5] = sin(Y[8]);
		U[5] = -Z[5];
		Z[6] = cos(Y[12]);
		U[6] = Z[6];
		Z[7] = sin(Y[12]);
		U[7] = -Z[7];
		U[8] = Z[5];
		U[9] = Z[4];
		U[10] = Z[7];
		U[11] = Z[6];
		U[12] = U[4]*U[6]+U[8]*U[10];
		U[13] = U[5]*U[6]+U[9]*U[10];
		U[14] = U[4]*U[7]+U[8]*U[11];
		U[15] = Z[3];
		U[16] = Z[2];
		U[17] = U[4]*U[10];
		U[18] = U[5]*U[10];
		U[19] = U[4]*U[11];
		U[20] = U[6]*U[8];
		U[21] = U[6]*U[9];
		U[22] = U[7]*U[8];
		U[23] = U[17]-U[20];
		Z[2] = U[21]-U[18];
		U[24] = -Z[2];
		Z[3] = U[22]-U[19];
		U[25] = -Z[3];
		U[26] = Z[1];
		U[27] = -Z[0];
		J[0] = U[0]*(U[3]*U[12]+U[16]*U[23])-U[26]*(U[3]*U[23]-U[12]*U[16]);
		J[1] = U[0]*(U[2]*U[13]+U[15]*U[24])-U[26]*(U[2]*U[24]-U[13]*U[15]);
		J[2] = U[1]*(U[2]*U[12]+U[15]*U[23])-U[27]*(U[2]*U[23]-U[12]*U[15]);
		J[3] = U[0]*(U[2]*U[14]+U[15]*U[25])-U[26]*(U[2]*U[25]-U[14]*U[15]);
		J[4] = cos(Y[14]);
		U[28] = U[2]*U[4]-U[8]*U[15];
		U[29] = U[3]*U[4]-U[8]*U[16];
		U[30] = U[2]*U[5]-U[9]*U[15];
		U[31] = U[8]*U[2]+U[4]*U[15];
		U[32] = U[3]*U[8]+U[4]*U[16];
		U[33] = U[2]*U[9]+U[5]*U[15];
		U[34] = U[0]*U[15]-U[2]*U[26];
		U[35] = U[0]*U[16]-U[3]*U[26];
		U[36] = U[1]*U[15]-U[2]*U[27];
		U[37] = U[0]*U[2]+U[15]*U[26];
		U[38] = U[0]*U[3]+U[16]*U[26];
		U[39] = U[1]*U[2]+U[15]*U[27];
		U[40] = -(U[4]*U[34]+U[8]*U[37]);
		U[41] = -(U[4]*U[35]+U[8]*U[38]);
		U[42] = -(U[5]*U[34]+U[9]*U[37]);
		U[43] = -(U[4]*U[36]+U[8]*U[39]);
		U[44] = U[4]*U[37]-U[8]*U[34];
		U[45] = U[4]*U[38]-U[8]*U[35];
		U[46] = U[5]*U[37]-U[9]*U[34];
		U[47] = U[4]*U[39]-U[8]*U[36];
		Z[0] = 0.34;
		Z[1] = 0.3;
		J[16] = Z[0]*(U[6]*U[32]-U[10]*U[29])-Z[1]*(U[6]*U[45]-U[10]*U[41]);
		Z[4] = 0.31;
		J[17] = Z[0]*(U[6]*U[33]-U[10]*U[30])+Z[2]*Z[4]-Z[1]*(U[6]*U[46]-U[10]*U[42]);
		J[18] = 1.*Z[1]*(U[10]*U[43]-U[6]*U[47]);
		Z[2] = 0.8;
		J[19] = Z[0]*(U[7]*U[31]-U[11]*U[28])+Z[3]*Z[4]-Z[2]*U[7]-Z[1]*(U[7]*U[44]-U[11]*U[40]);
		J[32] = Z[1]*(U[6]*U[41]+U[10]*U[45])-Z[0]*(U[6]*U[29]+U[10]*U[32]);
		J[33] = Z[1]*(U[6]*U[42]+U[10]*U[46])-U[13]*Z[4]-Z[0]*(U[6]*U[30]+U[10]*U[33]);
		J[34] = Z[1]*(U[6]*U[43]+U[10]*U[47]);
		J[35] = U[11]*Z[2]+Z[1]*(U[7]*U[40]+U[11]*U[44])-U[14]*Z[4]-Z[0]*(U[7]*U[28]+U[11]*U[31]);
	}
	else if( prb==2 ) {
		for(ti1=0;ti1<=2;ti1++)
			for(ti2=0;ti2<=4;ti2++)
				J[ti1*16+ti2] = 0.;
		J[0] = -1.;
		J[1] = -1.;
		J[2] = -1.;
		J[3] = 1.;
		J[4] = 1.;
		U[0] = cos(Y[12]);
		U[1] = sin(Y[8]);
		U[2] = cos(Y[6]);
		U[3] = cos(Y[8]);
		U[4] = sin(Y[6]);
		Z[0] = Y[9]+Y[7];
		Z[1] = U[3]*U[4];
		Z[2] = U[1]*U[2];
		U[5] = Z[0]*Z[1]+Z[0]*Z[2];
		Z[1] = Z[2]+Z[1];
		U[6] = Z[1];
		U[7] = Z[1];
		U[8] = sin(Y[12]);
		Z[2] = U[2]*U[3];
		Z[3] = U[4]*U[1];
		U[9] = Z[0]*Z[3]-Z[0]*Z[2];
		Z[0] = Z[3]-Z[2];
		U[10] = Z[0];
		U[11] = Z[0];
		U[12] = cos(Y[10]);
		U[13] = sin(Y[10]);
		Z[2] = U[4]*U[13];
		Z[3] = U[2]*U[12];
		Z[4] = Z[3]-Z[2];
		U[14] = Z[4];
		Z[5] = Y[7]+Y[11];
		Z[6] = U[4]*U[12];
		Z[7] = U[2]*U[13];
		U[15] = Z[5]*Z[6]+Z[5]*Z[7];
		Z[6] = Z[7]+Z[6];
		U[16] = Z[6];
		U[17] = Z[6];
		U[18] = Z[6];
		U[19] = Z[3]*Z[5]-Z[2]*Z[5];
		U[20] = Z[4];
		U[21] = Z[4];
		Z[2] = U[14]*Y[9]+U[19];
		Z[3] = U[18]*Y[9]+U[15];
		U[22] = -(U[1]*Z[2]+U[3]*Z[3]);
		U[23] = -(U[1]*U[20]+U[3]*U[16]);
		Z[4] = U[1]*U[14]+U[3]*U[18];
		U[24] = -Z[4];
		U[25] = -(U[1]*U[21]+U[3]*U[17]);
		U[26] = U[3]*Z[2]-U[1]*Z[3];
		U[27] = U[3]*U[20]-U[1]*U[16];
		Z[2] = U[1]*U[18]-U[3]*U[14];
		U[28] = -Z[2];
		U[29] = U[3]*U[21]-U[1]*U[17];
		U[30] = -Z[0];
		U[31] = Z[1];
		U[32] = -Z[2];
		U[33] = Z[4];
		Z[0] = 0.34;
		Z[1] = 0.3;
		J[16] = Z[0]*(U[0]*U[6]+U[8]*U[10])+Z[1]*(U[0]*U[23]+U[8]*U[27]);
		Z[2] = 0.31;
		Z[3] = Z[2]*(U[3]*U[8]-U[0]*U[1]);
		J[17] = Z[0]*(U[0]*U[7]+U[8]*U[11])+Z[1]*(U[0]*U[24]+U[8]*U[28])-Z[3];
		J[18] = Z[1]*(U[0]*U[25]+U[8]*U[29]);
		Z[4] = 0.8;
		J[19] = Z[4]*U[0]+Z[1]*(U[0]*U[33]-U[8]*U[32])+Z[3]-Z[0]*(U[0]*U[31]-U[8]*U[30]);
		J[32] = Z[0]*(U[6]*U[8]-U[0]*U[10])-Z[1]*(U[0]*U[27]-U[8]*U[23]);
		Z[2] = Z[2]*(U[0]*U[3]+U[1]*U[8]);
		J[33] = Z[0]*(U[7]*U[8]-U[0]*U[11])+Z[2]-Z[1]*(U[0]*U[28]-U[8]*U[24]);
		J[34] = 1.*Z[1]*(U[8]*U[25]-U[0]*U[29]);
		J[35] = U[8]*Z[4]+Z[1]*(U[0]*U[32]+U[8]*U[33])-Z[0]*(U[0]*U[30]+U[8]*U[31])-Z[2];
	}
}

static void inpfn(double T, double *U)
{

}

/*
	Projection: Use Rblkp,Jblkp constraint residual and Jacobian functions to
	project the input solution x back onto the constraint manfold.

	Return codes:
	0 - Successful completion
	1 - Entry of Residual or Jacobian is undefined/infinity
	2 - Row of Jacobian is zero, but residual is nonzero
	3 - Iteration limit reached
*/
#define JERR 1

static int Projection(
	double t,		/* Current time */
	double *x,		/* Current solution (updated) */
	double tol,		/* Tolerance limit for iteration */
	int maxiter,	/* Max iteration limit */
	double *w		/* Weight vector */
)
{
	int i, j, k, r, c, cb, iter, nc2;
	M_INT n, nblk, nc, ip[NDIFF],per[NDIFF],varmap[NDIFF];
	double scl, resmag, val, val2, R[NDIFF],J[NCON*NDIFF],A[NDIFF*NDIFF],
#ifdef JERR
				Rerr[NCON],Jerr[NCON*NDIFF],
#endif
				ULP=4.440223e-16;
#if NCON*NCON>NDIFF
	double iA[NCON*NCON];
#else
	double iA[NDIFF];
#endif

	/* Get number of blocks */
	Rblkp(t, x, R, 0, 0);
	nblk = (M_INT)(R[0]);
	for(cb=1;cb<=nblk;cb++) {
		/* Get problem size */
		Rblkp(t, x, R, cb, 1);
		nc = (M_INT)(R[0]);
		n = (M_INT)(R[1]);
		/* Get dep. variable mapping */
		Rblkp(t, x, R, cb, 2);
		for(i=0;i<n;i++) varmap[i]=(M_INT)(R[i])-1;

		for(iter=0;iter<maxiter;iter++) {

			/* Reset var. mapping */
			for(i=0;i<n;i++) per[i]=varmap[i];
			/* Compute the Jacobian and Residual at the current solution */
			Rblkp(t, x, R, cb, 3);
			Jblkp(t, x, J, cb);
#ifdef JERR
			for(i=0;i<nc;i++) {
				Rerr[i]=ULP*fabs(R[i]);
				for(j=0;j<n;j++) Jerr[i*NDIFF+j]=ULP*fabs(J[i*NDIFF+j]);
			}
#endif

			/* Scale the columns by the weight factor */
			if( w ) {
				for(j=0;j<n;j++) {
					for(i=0;i<nc;i++)
						J[NDIFF*i+j] /= w[per[j]];
#ifdef JERR
					for(i=0;i<nc;i++)
						Jerr[NDIFF*i+j] /= w[per[j]];
#endif
				}
			}

			/* Rescale rows of Jacobian so that maximum coeff is 1, validating */
			resmag = 0.0;
			for(i=0;i<nc;i++) {
				if( IS_UNDEF(R[i]) ) return(1);
				val = 0.0;
				for(j=0;j<n;j++) {
					if( IS_UNDEF(J[i*NDIFF+j]) ) return(1);
					val2 = fabs(J[i*NDIFF+j]);
					if( val2>val ) val = val2;
				}
				if( val==0. ) {
					if( R[i]!=0. )
						return(2);
				}
				else {
					val = 1.0/val;
					for(j=0;j<n;j++) J[i*NDIFF+j] *= val;
					R[i] *= val;
#ifdef JERR
					val = fabs(val);
					for(j=0;j<n;j++) Jerr[i*NDIFF+j] *= val;
					Rerr[i] *= val;
#endif
					resmag += R[i]*R[i];
				}
			}

			/* Compute J_hat from J
				The solving process will select the row with the largest residual,
				then choose the largest coeff, computing an approx.  of the condition
				as we go, stopping when the condition becomes too poor. */
			nc2 = nc;
			scl = 1.0;
			i = 0;
			while( i<nc2 ) {
				/* Search for row with largest residual */
				resmag = fabs(R[i]); r = i;
				for(j=i+1;j<nc2;j++) {
					val2 = fabs(R[j]);
					if( val2>resmag ) { resmag = val2; r = j; }
				}
				/* Check for termination on the first row of this iteration */
				if( i==0 && ( resmag<=tol || iter>=maxiter )) {
					nc2 = n+1; break;
				}

				/* Row 'r' has largest residual 'val', locate column with
					largest coeff */
				val = fabs(J[r*NDIFF+i]); c = i;
				for(j=i+1;j<n;j++) {
					val2 = fabs(J[r*NDIFF+j]);
					if( val2>val ) { val = val2; c = j; }
				}

#ifdef JERR
				if( (val+Jerr[r*NDIFF+c])*scl-val>=val*pow(fabs(tol),0.75) ) {
#else
				if( scl*val<sqrt(tol) ) {
#endif
					/* Coefficient is too small - remove row */
					if( r!=nc2-1 ) {
						for(j=0;j<n;j++) J[r*NDIFF+j] = J[(nc2-1)*NDIFF+j];
						R[r] = R[nc2-1];
#ifdef JERR
						for(j=0;j<n;j++) Jerr[r*NDIFF+j] = Jerr[(nc2-1)*NDIFF+j];
						Rerr[r] = Rerr[nc2-1];
#endif
					}
					nc2--;
				}
				else {
					/* Adjust condition estimate */
					scl *= val;
					/* Row/Column exchanges */
					if( c!=i ) {
						for(j=0;j<nc2;j++) { val=J[j*NDIFF+i]; J[j*NDIFF+i]=J[j*NDIFF+c]; J[j*NDIFF+c]=val; }
#ifdef JERR
						for(j=0;j<nc2;j++) { val=Jerr[j*NDIFF+i]; Jerr[j*NDIFF+i]=Jerr[j*NDIFF+c]; Jerr[j*NDIFF+c]=val; }
#endif
						j=per[i]; per[i]=per[c]; per[c]=j;
					}
					if( r!=i ) {
						for(j=i;j<n;j++) { val=J[i*NDIFF+j]; J[i*NDIFF+j]=J[r*NDIFF+j]; J[r*NDIFF+j]=val; }
						val=R[i]; R[i]=R[r]; R[r]=val;
#ifdef JERR
						for(j=i;j<n;j++) { val=Jerr[i*NDIFF+j]; Jerr[i*NDIFF+j]=Jerr[r*NDIFF+j]; Jerr[r*NDIFF+j]=val; }
						val=Rerr[i]; Rerr[i]=Rerr[r]; Rerr[r]=val;
#endif
					}
					/* Rescale if necessary */
					if( J[i*NDIFF+i]!=1.0 ) {
						val = 1.0/J[i*NDIFF+i];
						J[i*NDIFF+i] = 1.0;
						for(j=i+1;j<n;j++) J[i*NDIFF+j] = J[i*NDIFF+j]*val;
						R[i] *= val;
#ifdef JERR
						val = fabs(val);
						for(j=i;j<n;j++) Jerr[i*NDIFF+j] = Jerr[i*NDIFF+j]*val;
						Rerr[i] *= val;
#endif
					}
					/* Backsub */
					for(r=0;r<nc2;r++)
						if( r!=i && J[r*NDIFF+i]!=0.0 ) {
							for(c=i+1;c<n;c++) J[r*NDIFF+c] -= J[r*NDIFF+i]*J[i*NDIFF+c];
							R[r] -= J[r*NDIFF+i]*R[i];
#ifdef JERR
							val = fabs(J[r*NDIFF+i]);
							for(c=i+1;c<n;c++) Jerr[r*NDIFF+c] += val*Jerr[i*NDIFF+c];
							Rerr[r] += val*Rerr[i];
#endif
							J[r*NDIFF+i] = 0.0;
						}
					if( i==n-1 ) {
						nc2=n;
						break;
					}
					else
						i++;
				}
			}
			if( nc2==n+1 )
				/* Termination: residual within bound on first row */
				break;

			/* Compute A = J_hat * J_hat^T */
			for(j=0;j<nc2;j++)
				for(i=0;i<=j;i++) {
					A[i*nc2+j] = 0.0;
					for(k=0;k<n;k++) A[i*nc2+j]+=J[i*NDIFF+k]*J[j*NDIFF+k];
				}
			for(i=0;i<nc2;i++)
				for(j=0;j<i;j++)
					A[i*nc2+j]=A[j*nc2+i];

			/* Construct (J_hat * J_hat^T)^(-1) in iA */
			for(i=0;i<nc2*nc2;i++) iA[i]=0.0;
			for(i=0;i<nc2;i++) iA[i*(1+nc2)]=1.0;
			DecompCInc(nc2, A, nc2, ip);
			MultiSolveCInc(nc2, A, nc2, ip, nc2, iA, nc2);

			/* Multiply iA (nc2 x nc2) with R (nc2 x 1) to A (nc2 x 1)
				A = (J_hat * J_hat^T)^(-1) * R */
			for(i=0;i<nc2;i++) {
				A[i] = 0.0;
				for(k=0;k<nc2;k++) A[i] += iA[i*nc2+k]*R[k];
			}

			/* Multiply J_hat^T (NDIFF x nc2) with A (nc2 x 1) to iA (NDIFF x 1)
				 iA = J_hat^T * (J_hat * J_hat^T)^(-1) * R */
			for(i=0;i<n;i++) {
				iA[i] = 0.0;
				for(k=0;k<nc2;k++) iA[i] += J[k*NDIFF+i]*A[k];
			}

			val=0.0; for(i=0;i<n;i++) val+=x[per[i]]*x[per[i]]; val=sqrt(val);
			val2=0.0; for(i=0;i<n;i++) val2+=iA[i]*iA[i]; val2=sqrt(val2);
			val = val2/((val>0.1*val2)?val:(0.1*val2));
			if( val>0.1 ) {
				/* Solution is very far off - Use relaxed */
				val2 = ( tol>0.1/val )?tol:(0.1/val);
				if( w )
					for(i=0;i<n;i++) x[per[i]]-=val2*iA[i]/w[per[i]];
				else
					for(i=0;i<n;i++) x[per[i]]-=val2*iA[i];
			}
			else {
				/* Direct newton */
				if( w )
					for(i=0;i<n;i++) x[per[i]]-=iA[i]/w[per[i]];
				else
					for(i=0;i<n;i++) x[per[i]]-=iA[i];
			}
		}
		if( iter==maxiter ) return(3);
	}
	return(0);
}

/*
	ProjectInitial: Use weighted projection to find consistent initial
	data with fixed initial values.

	Return codes:
	0 - Successful completion
	2 - Projection not converging
	3 - Iteration limit reached
*/
static int ProjectInitial(
	double t,			/* t0 */
	double *x,			/* Current solution (updated) */
	double ptol,		/* Tolerance limit for iteration for projection */
	int pmaxiter,	/* Max iteration limit for projection */
	int *icmask,	/* Fixed IC mask vector */
	double tol,		/* Convergence tolerance */
	int maxiter,	/* Max limit for number of calls to projection */
	double W			/* Default fixed IC weight */
)
{
	int i, ip, iter;
	double delta1, delta2, val, w[NDIFF], ic[NDIFF];

	for(i=0;i<NDIFF;i++) {
		if( icmask[i]==0 ) {
			w[i] = 1.0;
			ic[i] = 0.0;
		}
		else {
			w[i] = W;
			ic[i] = x[i];
		}
	}

	delta1 = 1.0;
	for(iter=0;iter<maxiter;iter++) {
		/* Do weighted projection and check fixed IC deviation */
		ip=Projection(t,x,ptol,pmaxiter,w);
		if( ip>0 && ip!=3 ) return(2);

		delta2 = 0.0;
		for(i=0;i<NDIFF;i++)
			if( w[i]!=1.0 ) {
				val = 0.5*(fabs(x[i])+fabs(ic[i]));
				val = ( val > 1.0e-3 ) ? val : 1.0e-3;
				delta2+=fabs((x[i]-ic[i]))/(val);
			}

		/* Return if projection converged */
		if( delta2<=tol ) break;
		/* Check for adequate convergence rate */
		if( iter>2 && (delta2/delta1 > 0.9) ) return(2);
		/* Check iteration limit */
		if( iter==maxiter-1 ) { iter++; break; }

		/* Overwrite the solution vector with fixed IC values,
		   for next pass. */
		for(i=0;i<NDIFF;i++)
			if( w[i]!=1.0 ) x[i]=ic[i];

		delta1 = delta2;
	}
	/* Check iteration limit */
	if( iter==maxiter ) return(3); else return(0);
}

static void SolverUpdate(double *u, int internal, SolverStruct *S)
{
	int i;

	inpfn(S->w[0],u);
	for(i=0;i<NINP;i++) S->w[i+NDIFF+NIX1-NINP+1]=u[i];
	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
		SolverError(S,0,"index-1 and derivative evaluation failure");
		return;
	}
	if(internal) return;
	i=Projection(S->w[0],&S->w[1],CONTOL,CONITER,NULL);
	if(i>0 && i!=3) {
		SolverError(S,0,"constraint projection failure");
		return;
	}
	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
		SolverError(S,0,"index-1 and derivative evaluation failure");
		return;
	}
	otp(S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	S->py[ 0]=S->w[ 7];
	S->py[ 1]=S->w[ 8];
	S->py[ 2]=S->w[ 9];
	S->py[ 3]=S->w[10];
	S->py[ 4]=S->w[53];
	S->py[ 5]=S->w[54];
	S->py[ 6]=S->w[55];
	S->py[ 7]=S->w[65];
	S->py[ 8]=S->w[66];
	S->py[ 9]=S->w[67];
	S->py[10]=S->w[68];
	S->py[11]=S->w[69];
	S->py[12]=S->w[70];
	S->py[13]=S->w[47];
	S->py[14]=S->w[48];
	S->py[15]=S->w[49];
	S->py[16]=S->w[50];
	S->py[17]=S->w[51];
	S->py[18]=S->w[52];
	S->py[19]=S->w[56];
	S->py[20]=S->w[57];
	S->py[21]=S->w[58];
	S->py[22]=S->w[59];
	S->py[23]=S->w[60];
	S->py[24]=S->w[61];
	S->py[25]=S->w[62];
	S->py[26]=S->w[63];
	S->py[27]=S->w[64];
	S->py[28]=S->w[13];
	S->py[29]=S->w[14];
	S->py[30]=S->w[15];
	S->py[31]=S->w[16];
}

static void SolverOutputs(double *y, SolverStruct *S)
{
	otp(S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	y[ 0]=S->w[ 7];
	y[ 1]=S->w[ 8];
	y[ 2]=S->w[ 9];
	y[ 3]=S->w[10];
	y[ 4]=S->w[53];
	y[ 5]=S->w[54];
	y[ 6]=S->w[55];
	y[ 7]=S->w[65];
	y[ 8]=S->w[66];
	y[ 9]=S->w[67];
	y[10]=S->w[68];
	y[11]=S->w[69];
	y[12]=S->w[70];
	y[13]=S->w[47];
	y[14]=S->w[48];
	y[15]=S->w[49];
	y[16]=S->w[50];
	y[17]=S->w[51];
	y[18]=S->w[52];
	y[19]=S->w[56];
	y[20]=S->w[57];
	y[21]=S->w[58];
	y[22]=S->w[59];
	y[23]=S->w[60];
	y[24]=S->w[61];
	y[25]=S->w[62];
	y[26]=S->w[63];
	y[27]=S->w[64];
	y[28]=S->w[13];
	y[29]=S->w[14];
	y[30]=S->w[15];
	y[31]=S->w[16];
}

static void RK4Step(double *u, SolverStruct *S)
{
	int i;
	double y[NEQ+1],yp1[NDFA],yp2[NDFA],yp3[NDFA];

	for(i=0;i<NEQ+1;i++) y[i]=S->w[i];
	for(i=0;i<NDIFF;i++) yp1[i]=S->w[1+NEQ+NPAR+i];
	S->w[0]+=0.5*S->h;
	for(i=0;i<NDIFF;i++) S->w[i+1]+=0.5*S->h*S->w[1+NEQ+NPAR+i];
	SolverUpdate(u,1,S);
	for(i=0;i<NDIFF;i++) yp2[i]=S->w[1+NEQ+NPAR+i];
	for(i=0;i<NDIFF;i++) S->w[i+1]=y[i+1]+0.5*S->h*S->w[1+NEQ+NPAR+i];
	SolverUpdate(u,1,S);
	for(i=0;i<NDIFF;i++) yp3[i]=S->w[1+NEQ+NPAR+i];
	S->w[0]=y[0]+S->h;
	for(i=0;i<NDIFF;i++) S->w[i+1]=y[i+1]+S->h*S->w[1+NEQ+NPAR+i];
	SolverUpdate(u,1,S);
	for(i=0;i<NDIFF;i++) S->w[i+1]=y[i+1]+S->h/6.0*(yp1[i]+2.0*(yp2[i]+yp3[i])+S->w[1+NEQ+NPAR+i]);
	SolverUpdate(u,0,S);
}

static void SolverSetup(double t0, double *ic, double *u, double *p, double *y, double h, SolverStruct *S)
{
	int i, j;

	S->h = h;
	S->iw=NULL;
	S->w[0] = t0;
	S->w[1] =  0.00000000000000000e+00;
	S->w[2] =  0.00000000000000000e+00;
	S->w[3] =  0.00000000000000000e+00;
	S->w[4] =  0.00000000000000000e+00;
	S->w[5] =  0.00000000000000000e+00;
	S->w[6] =  0.00000000000000000e+00;
	S->w[7] =  2.35619449019234484e+00;
	S->w[8] =  0.00000000000000000e+00;
	S->w[9] =  0.00000000000000000e+00;
	S->w[10] =  0.00000000000000000e+00;
	S->w[11] =  2.13122223972796787e+00;
	S->w[12] =  0.00000000000000000e+00;
	S->w[13] =  2.04319657053562986e+00;
	S->w[14] =  0.00000000000000000e+00;
	S->w[15] = -6.97372494205110383e-01;
	S->w[16] =  0.00000000000000000e+00;
	S->w[17] =  2.71542242760388053e+00;
	S->w[18] =  9.94847980375252239e-01;
	S->w[19] =  3.05000000000000026e-17;
	S->w[20] =  1.00000000000000000e+00;
	S->w[21] =  0.00000000000000000e+00;
	S->w[22] =  0.00000000000000000e+00;
	S->w[23] =  8.00000000000000017e-02;
	S->w[24] =  1.00000000000000000e+00;
	S->w[25] =  0.00000000000000000e+00;
	S->w[26] =  0.00000000000000000e+00;
	S->w[27] =  8.00000000000000017e-02;
	S->w[28] =  1.00000000000000000e+00;
	S->w[29] =  0.00000000000000000e+00;
	S->w[30] =  0.00000000000000000e+00;
	S->w[31] =  8.00000000000000017e-02;
	S->w[32] =  1.00000000000000000e+00;
	S->w[33] =  0.00000000000000000e+00;
	S->w[34] =  0.00000000000000000e+00;
	S->w[35] =  8.00000000000000017e-02;
	S->w[36] =  1.00000000000000000e+00;
	S->w[37] =  0.00000000000000000e+00;
	S->w[38] =  0.00000000000000000e+00;
	S->w[39] =  8.00000000000000017e-02;
	S->w[40] =  1.00000000000000000e+00;
	S->w[41] =  0.00000000000000000e+00;
	S->w[42] =  0.00000000000000000e+00;
	S->w[43] =  8.00000000000000017e-02;
	S->w[44] = -1.24638300445410657e+01;
	S->w[45] = -3.58834000339148007e+00;
	S->w[46] =  1.24710284556705808e+01;
	S->w[47] =  0.00000000000000000e-01;
	S->w[48] =  0.00000000000000000e-01;
	S->w[49] =  0.00000000000000000e-01;
	S->w[50] =  0.00000000000000000e-01;
	S->w[51] =  0.00000000000000000e-01;
	S->w[52] =  0.00000000000000000e-01;
	S->w[53] =  2.74681801879055598e+00;
	S->w[54] =  0.00000000000000000e+00;
	S->w[55] =  3.85920341984191495e+00;
	S->w[56] =  2.74681801879055598e+00;
	S->w[57] =  0.00000000000000000e+00;
	S->w[58] =  3.85920341984191495e+00;
	S->w[59] =  2.40416305603426195e-01;
	S->w[60] =  0.00000000000000000e+00;
	S->w[61] =  6.95836943965738308e-02;
	S->w[62] =  0.00000000000000000e+00;
	S->w[63] =  0.00000000000000000e+00;
	S->w[64] =  0.00000000000000000e-01;
	S->w[65] =  0.00000000000000000e+00;
	S->w[66] =  0.00000000000000000e+00;
	S->w[67] =  0.00000000000000000e-01;
	S->w[68] =  2.40416305603426195e-01;
	S->w[69] =  0.00000000000000000e+00;
	S->w[70] =  6.95836943965738308e-02;
	S->w[71] =  5.00000000000000000e+00;
	S->w[72] =  5.00000000000000000e+00;
	S->w[73] =  0.00000000000000000e+00;
	S->w[74] =  0.00000000000000000e+00;
	S->w[75] =  0.00000000000000000e+00;
	S->w[76] =  0.00000000000000000e+00;
	S->w[77] =  0.00000000000000000e+00;
	S->w[78] =  0.00000000000000000e+00;
	S->w[79] =  0.00000000000000000e+00;
	S->w[80] =  0.00000000000000000e+00;
	S->w[81] =  1.00000000000000000e+00;
	S->w[82] =  1.00000000000000000e+00;

	for(i=0;i<NDIFF;i++) S->w[i+NEQ+NPAR+1]=0.0;

	inpfn(S->w[0],u);
	for(i=0;i<NINP;i++) S->w[i+NDIFF+NIX1-NINP+1]=u[i];
	if(ic) for(i=0,j=0;i<NDIFF;i++) if(icvis[i]) { if(!IS_UNDEF(ic[j])) S->w[i+1]=ic[j]; j++; }
	if(p) for(i=0;i<NPAR;i++) S->w[i+NEQ+1]=p[i];
	S->w[NEQ+NPAR+1]=0.0;
	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
		SolverError(S,0,"index-1 and derivative evaluation failure");
		return;
	}
#if INITCONITER>0
	i=ProjectInitial(S->w[0],&S->w[1],INITCONTOL,INITCONITER,icmask,INITTOL,INITITER,INITWEIGHT);
	if(i>0 && i!=3) {
		SolverError(S,0,"constraint projection failure");
		return;
	}
	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
		SolverError(S,0,"index-1 and derivative evaluation failure");
		return;
	}
#endif
	SolverOutputs(y,S);
}

/*
	Parametrized simulation driver
*/
#define EPT 1

#ifdef FROM_MAPLE
#include <time.h>

EXP long M_DECL ParamDriverMC(double t0, double dt, long npts, long stepsperpt, double *ic, double *p, double *out, char *errbuf, long internal, ALGEB halt)
#else
EXP long M_DECL ParamDriverMC(double t0, double dt, long npts, long stepsperpt, double *ic, double *p, double *out, char *errbuf, long internal)
#endif
{
	double u[NINP],y[NOUT+1];
	long i,j,k;
#ifdef FROM_MAPLE
	long ictr=0,pct=0;
	char buf[200];
	double tv1,tv2;
#endif
	SolverStruct S;

	/* Setup */
	for(j=0;j<=NOUT;j++) y[j]=0.0; /* Compiler warnings */
	for(i=0;i<(npts+EPT*(npts-1))*(NOUT+1);i++) out[i]=*dsn_undef;
	S.w=(double *)malloc((1+2*NEQ+NPAR+NDFA+NEVT)*sizeof(double));
	if(internal==0) S.err=0; else S.err=-1;
	S.buf=errbuf;
	SolverSetup(t0,ic,u,p,y,dt,&S);
	/* Output */
	out[0]=t0; for(j=0;j<NOUT;j++) out[j+1]=y[j];
	/* Integration loop */
#ifdef FROM_MAPLE
	tv1=clock()/(1.0*CLOCKS_PER_SEC);
#endif
	k=1;
	for(i=1;i<npts;i++) {
		for(j=0;j<stepsperpt;j++) {
			/* Take a step with states */
			RK4Step(u,&S);
			if( S.err>0 ) break;
#ifdef FROM_MAPLE
			ictr++;
			if(ictr>=100) {
				if( kv->getInterruptValue() ) {
					free(S.w);
					return(i);
				}
				tv2=clock()/(1.0*CLOCKS_PER_SEC);
				if(tv2-tv1>0.5) {
					if( halt!=NULL && !kv->isUnassignedName(halt) ) {
						free(S.w);
						return(i);
					}
					tv1=tv2;
				}
				ictr=0;
			}
#endif

		}
#ifdef FROM_MAPLE
		j=(100*i)/(npts-1);
		if(j>pct) {
			pct=j;
			sprintf(buf,"ProgressUpdate: %li %f",(long)pct,S.w[0]);
			kv->userinfo(1,"MapleSimProgressUpdate",buf);
		}
#endif
		/* Output */
#if EPT==1
		out[k*(NOUT+1)]=S.w[0]; for(j=0;j<NOUT;j++) out[k*(NOUT+1)+j+1]=S.py[j];
		k++;
#endif
		SolverOutputs(y,&S);
		out[k*(NOUT+1)]=S.w[0]; for(j=0;j<NOUT;j++) out[k*(NOUT+1)+j+1]=y[j];
		k++;
	}
#ifdef _SOLVER_TERMINATE
	if(i==npts)
		SolverTerminate(&S);
#endif

	free(S.w);
	return(k);
}

/*
	Old interface - maintain for backward compatibility
*/
EXP long M_DECL ParamDriverC(double t0, double dt, long npts, double *ic, double *p, double *out, char *errbuf, long internal)
{
#ifdef FROM_MAPLE
	ALGEB a=NULL;

	return ParamDriverMC(t0,dt,npts,1,ic,p,out,errbuf,internal,a);
#else
	return ParamDriverMC(t0,dt,npts,1,ic,p,out,errbuf,internal);
#endif
}

#ifdef FROM_MAPLE
EXP ALGEB M_DECL ParamDriver( MKernelVector kv_in, ALGEB *args )
{
	double t0,tf,dt,*ic,*p,*out;
	M_INT nargs,bounds[4],npts,naout,stepsperpt,sppa=0,i;
	RTableSettings s;
	ALGEB outd,halt;
	char buf[10000];

	kv=kv_in;
	nargs=kv->numArgs((ALGEB)args);
	if( nargs<5 || nargs>7 )
		kv->error("incorrect number of arguments");

	/* Process time vals */
	if( !kv->isNumeric(args[1]) )
		kv->error("argument #1, the initial time, must be numeric");
	t0=kv->mapleToFloat64(args[1]);
	if( !kv->isNumeric(args[2]) )
		kv->error("argument #2, the final time, must be numeric");
	tf=kv->mapleToFloat64(args[2]);
	if( t0>=tf )
		kv->error("the final time must be larger than the initial time");
	if( !kv->isNumeric(args[3]) )
		kv->error("argument #3, the time step, must be a positive numeric value");
	dt=kv->mapleToFloat64(args[3]);
	if(dt<=0)
		kv->error("argument #3, the time step, must be a positive numeric value");

	/* Check for presence of stepsperpt argument */
	if( kv->isInteger(args[4]) && (stepsperpt=kv->mapleToInteger32(args[4]))>0 )
		sppa=1;
	else
		stepsperpt=1;
	npts=(M_INT)floor((tf+1e-10*dt-t0)/(stepsperpt*dt))+1;

	/* Processing ic in */
	if( NDIFF==0 )
		ic=NULL;
	else if( kv->isInteger(args[4+sppa]) && kv->mapleToInteger32(args[4+sppa])==0 )
		ic=NULL;
	else if( !kv->isRTable(args[4+sppa]) ) {
		ic=NULL;
		kv->error("argument #%1, the initial data, must be a 1..ndiff rtable",kv->toMapleInteger(4+sppa));
	}
	else {
		kv->rtableGetSettings(&s,args[4+sppa]);
		if( s.storage != RTABLE_RECT || s.data_type != RTABLE_FLOAT64 ||
			 s.num_dimensions != 1 || kv->rtableLowerBound(args[4+sppa],1)!=1 ||
			 kv->rtableUpperBound(args[4+sppa],1) != NSDIFF )
			kv->error("argument #%1, the initial data, must be a 1..ndiff rtable",kv->toMapleInteger(4+sppa));
		ic=(double *)kv->rtableData(args[4+sppa]);
	}

	/* Processing parameters in */
	if( NPAR==0 )
		p=NULL;
	else if( kv->isInteger(args[5+sppa]) && kv->mapleToInteger32(args[5+sppa])==0 )
		p=NULL;
	else if( !kv->isRTable(args[5+sppa]) ) {
		p=NULL;
		kv->error("argument #%1, the parameter data, must be a 1..npar rtable",kv->toMapleInteger(5+sppa));
	}
	else {
		kv->rtableGetSettings(&s,args[5+sppa]);
		if( s.storage != RTABLE_RECT || s.data_type != RTABLE_FLOAT64 ||
			 s.num_dimensions != 1 || kv->rtableLowerBound(args[5+sppa],1)!=1 ||
			 kv->rtableUpperBound(args[5+sppa],1) != NPAR )
			kv->error("argument #%1, the parameter data, must be a 1..npar rtable",kv->toMapleInteger(5+sppa));
		p=(double *)kv->rtableData(args[5+sppa]);
	}

	/* Output data table */
	if( nargs==6+sppa ) {
		outd=NULL;
		if( !kv->isRTable(args[6+sppa]) ) {
			out=NULL;
			naout=0;
			kv->error("argument #%1, the output data, must be a 1..npts,1..nout+1 C_order rtable",kv->toMapleInteger(6+sppa));
		}
		else {
			kv->rtableGetSettings(&s,args[6+sppa]);
			if( s.storage != RTABLE_RECT || s.data_type != RTABLE_FLOAT64 ||
			 	s.order != RTABLE_C || s.num_dimensions != 2 ||
			 	kv->rtableLowerBound(args[6+sppa],1)!=1 ||
			 	kv->rtableLowerBound(args[6+sppa],2)!=1 ||
			 	kv->rtableUpperBound(args[6+sppa],2) != NOUT+1 )
				kv->error("argument #%1, the output data, must be a 1..npts,1..nout+1 C_order rtable",kv->toMapleInteger(6+sppa));
			naout=kv->rtableUpperBound(args[6+sppa],1);
			if( naout<1 )
				kv->error("argument #%1, the output data, must have at least 1 output slot",kv->toMapleInteger(6+sppa));
			out=(double *)kv->rtableData(args[6+sppa]);
			if(naout<npts+EPT*(npts-1)) npts=(EPT+naout)/(EPT+1);
		}
	}
	else {
		kv->rtableGetDefaults(&s);
		bounds[0]=1; bounds[1]=npts+EPT*(npts+1);
		bounds[2]=1; bounds[3]=NOUT+1;
		s.storage=RTABLE_RECT;
		s.data_type=RTABLE_FLOAT64;
		s.order=RTABLE_C;
		s.num_dimensions=2;
		s.subtype=RTABLE_ARRAY;
		outd=kv->rtableCreate(&s,NULL,bounds);
		out=(double *)kv->rtableData(outd);
		naout=npts+EPT*(npts+1);
	}
	for(i=0;i<naout*(NOUT+1);i++) out[i]=*dsn_undef;

	halt=kv->toMapleName("_HALT_MAPLESIM_INTEGRATION",TRUE);

	i=ParamDriverMC(t0,dt,npts,stepsperpt,ic,p,out,buf,1,halt);

	/* All done */
	if(outd==NULL)
		return(kv->toMapleInteger(i));
	else
		return(outd);
}
#endif
